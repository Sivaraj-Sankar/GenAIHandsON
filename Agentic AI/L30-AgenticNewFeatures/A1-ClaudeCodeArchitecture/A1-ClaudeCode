Claude Code Architecture 




Yes â€” I was able to access the link you shared and I also gathered information from other related posts in the same Claude Code Internals series and external technical summaries to extract the architecture design principles and core implementation ideas described.

ğŸ“ Claude Code Internals â€” Architecture Principles & Design

Below is a distilled and organized view of the architectural principles, key design patterns, and internal mechanisms used in Claude Code as best understood from reverse engineering and the Medium internals series:

ğŸ—ï¸ 1. Three-Layer Architecture

Claude Codeâ€™s internal design follows a layered architecture that separates concerns cleanly:

a. Presentation Layer

Terminal UI built using React + Ink, not raw ANSI escape sequences.

Declarative rendering, component-based structure for the interactive CLI.

UI components react to state changes (messages, permissions, tool output).

b. Core Services Layer

Orchestrates the agent loop, message state, tool integrations, and logic.

Implements session state, control flow, and execution policy.

Provides a unified context for all agent actions.

c. Integration Layer

Bridges between the core logic and external systems:

Calls to Anthropicâ€™s API for LLM responses.

Integration with MCP servers for extended tools.

Execution of local binaries and shell commands.

Design Principle: Separation of concerns for UI, core logic, and integrations improves maintainability and testability.

ğŸ” 2. The Agent Loop â€” Core Execution Pattern

The central pattern powering Claude Code is a loop that repeatedly:

Sends the accumulated messages to the LLM API.

Receives the modelâ€™s response.

Checks whether the model indicates completion (end_turn).

If tools were invoked, runs the tool and pushes results back into messages.

Repeats until the task is done.

This mechanism turns a stateless LLM into an autonomous executor capable of reading files, running commands, editing code, etc.

Pseudo-conceptual form:

while (true) {
  response = await callAPI(messages)
  if (response.stop_reason == "end_turn") break
  if (response.requiresToolExecution) {
     results = await executeTools(response)
     messages.push({ role: "user", content: results })
  }
}


Design Principle: Transform stateless language models into stateful autonomous agents via a disciplined control loop.

ğŸ§± 3. Session State Management (â€œr0â€)

Claude Code maintains a global session state object in memory:

Tracks current project directory

Stores messages and history

Holds configuration, tool state, and runtime variables

This global state (r0) acts as the nervous system of the agent â€” tools read from it and the loop updates it.

Design Principle: Centralized state allows coherent coordination between tools, the agent loop, and UI rendering.

ğŸ“© 4. Context & Message Structure

Everything flows through a messages array in Anthropicâ€™s API format:

User prompts

Model responses

Tool invocation blocks

Tool results

This structure preserves history and informs subsequent decisions. Too many messages grow the context and must be carefully managed due to token limits.

Design Principle: Maintain a unified conversation and execution trace so the agent can reason across steps.

ğŸ› ï¸ 5. Tool Design & Guardrails

Claude Code supports a rich set of tools:

File system access (read/write/search)

Shell/Bash execution

Code editing

MCP-provided tools

Todo & task tracking tools

Tools are deliberately designed with guardrails to prevent catastrophic failures â€” e.g., output truncation, execution sandboxing, uniqueness constraints.

Design Principle: Empower the agent with action capabilities while enforcing safety and correctness boundaries.

ğŸ”„ 6. Context Length & Management

Handling large projects means large contexts. Claude Codeâ€™s design acknowledges:

Token limits (up to 200K or 1M with extended context)

System prompts and tool definitions consume significant tokens

Efficient context management is critical to cost & accuracy.

Design Principle: Architect solutions around realistic context window constraints.

ğŸ¯ 7. Extensibility via MCP & Connectors

Claude Code integrates with Model Context Protocol (MCP) servers to extend capabilities:

Servers provide custom tools via JSON RPC

Permissions are enforced via an internal system

This allows plugin-style extensibility into the core execution loop.

Design Principle: Enable extensibility by decoupling core agent logic from external tools.

ğŸ“ 8. Declarative UI via React + Ink

Instead of classic CLI paradigms:

UI elements are React components

State drives rendering

Agents can produce rich interactive screens even in terminals.

Design Principle: Treat CLI interfaces as reactive applications, improving usability and consistency.

ğŸ§± 9. Bundling & Dependency Strategy

Claude Code ships as a self-contained bundle:

Includes native binaries (ripgrep)

WebAssembly modules for parsing and rendering

Zero reliance on external dependencies

This ensures reproducibility and ease of installation.

Design Principle: Distribute a fully packaged runtime for reliability and developer convenience.

ğŸ”„ 10. Tools + Loop = Actionable Agents

By combining:

Structured tool interfaces

Persistent session state

A control loop that reasons and acts

Claude Code creates a system that goes beyond prompting to actual automated execution.

Design Principle: An LLM agent becomes truly useful when its reasoning translates into verified actions.

âœ… Summary of Architecture Principles
Principle Area	Key Idea
Layered Architecture	Separate UI, Core Logic, Integration
Autonomous Agent Loop	Convert conversation into effectual actions
Central Session State	Shared state for tools and execution
Structured Context	Maintain rich message history
Guarded Tools	Controlled access for safety
Context Management	Respect token and memory limitations
Extensibility	MCP tools & plugin mechanisms
Reactive UI	Declarative terminal interface
Self-Contained Distribution	Bundle all runtime components
Action Execution	Beyond text generation to real tasks

If you want, I can also generate a visual diagram or a sequence flow showing how an individual request flows through Claude Codeâ€™s architecture (from CLI input â†’ LLM call â†’ tool execution â†’ output). Just let me know!

https://kotrotsos.medium.com/claude-code-internals-lessons-learned-and-whats-next-551092abeb5d






-------------------------------




I cannot retrieve or show the full article text exactly as-published from Medium â€” that content is behind Mediumâ€™s member paywall and is copyrighted, and I donâ€™t have special access to bypass that. What I can do is provide you with everything that is publicly visible or extractable about that article as well as a comprehensive reconstruction/summary of its contents, including key lessons and structure based on what is available and related posts.

Hereâ€™s what we do have:

ğŸ“„ Article: â€œClaude Code Internals: Lessons Learned and Whatâ€™s Nextâ€

Author: Marco Kotrotsos
Published: Jan 16, 2026
Length: ~6 min read
Part of: 15-part series on reverse engineering Claude Code

The article is a bonus summarizing and distilling key insights from the full internals series. The publicly visible portion shows:

â¤ Title and Opening

Title: â€œClaude Code Internals: Lessons Learned and Whatâ€™s Nextâ€

Subtitle: â€œWhat I have learned reverse engineering Claude Codeâ€

It frames the piece as a distilled summary of lessons from a 15-part series on how Claude Code works.

It describes the journey from a single JavaScript file to a complete mental model of a production AI coding assistant.

Emphasis is on battle-tested solutions to real problems rather than theoretical design.

â¤ Visible Section
Lesson 1: The Loop Is Everything

The article starts with the first lesson, showing the core agent pattern:

while (true) {
  const response = await callAPI(messages);
  messages.push(response);

  if (response.stop_reason === "end_turn") break;
  const results = await executeTools(response);
  messages.push({ role: "user", content: results });
}


This snippet illustrates the agent loop that turns a stateless LLM API into a stateful autonomous system.

The loop:

Sends messages to the LLM.

Appends the modelâ€™s response.

If stop_reason is end_turn, exit.

Otherwise execute tools indicated by the model.

Push tool results back into the messages array.

This pattern is described as the heart of Claude Code.

ğŸ“Œ Reconstructed Full Perspective of This Article

Because the published preview only shows the top, hereâ€™s a comprehensive reconstruction / detailed bullet summary based on what Medium and related posts in the series make clear about the lessons and whatâ€™s next:

ğŸ§  Overall Purpose

The article serves as a high-level synthesis of the entire series on Claude Code internals, focusing on:

What patterns emerged

Which design choices matter the most

How to build your own coding agent

Where the design shines and where itâ€™s heading

ğŸ“Œ Likely Main Lessons Covered

(These are consistent with themes in the related parts of the series)

Lesson 1 â€” The Agent Loop Is the Core

The loop is how Claude Code turns LLM responses into actions (tools, commands, edits).

It is the fundamental execution engine.

Lesson 2 â€” Structured Messages & Context Management

Claude Code uses rich message structures to drive actions, previously covered in the series.

Understanding how messages, tool_use blocks, and tool_result blocks accumulate is key.

Lesson 3 â€” Session State Is Central

A global state object (r0) holds project directory, history, tool args, and much more.

Session state makes the agent stateful.

Lesson 4 â€” Tool Design With Guardrails

Tools (file read/write, bash, search) are carefully constrained to prevent unsafe actions.

Every tool exists because of real problems discovered during development.

Lesson 5 â€” Telemetry Matters

Extensive telemetry tracks token costs, performance, feature usage â€” crucial for both billing and introspection.

Lesson 6 â€” Context Limits Drive Architecture

Because context windows are finite (e.g., 200k tokens, 1M with extended models), Claude Code must manage context carefully.

Too much history interferes with accuracy; too little loses project memory.

Lesson 7 â€” Next Steps / Whatâ€™s Next

Although the article preview ends early, â€œWhatâ€™s Nextâ€ likely addresses:

Building your own agentic assistant

Generalizing lessons to other domains

Strategies to improve reliability and tooling

Where future designs will evolve

(This projection is consistent with how the author structured other summary pieces in the series.)

ğŸ§  Meta Lessons From the Series (Context for the Article)

To understand the full article, hereâ€™s what the underlying 15-part series covers, because the summary article distills from them:

Part	Topic
1	High-level architecture
2	The agent loop
3	Message structure
4	Tool execution pipeline
5	Tools reference
6	Session state
12	Request lifecycle
13	Context management
15	Telemetry & metrics
ğŸ“Œ Key Takeaways You Would Get From the Full Article

Hereâ€™s what the author intended you to learn:

ğŸ”¹ The most important technical insight

The agent loop is not accidental â€” itâ€™s the execution core that allows the model to reason, plan, and act.

ğŸ”¹ The architecture isnâ€™t just API calls

Itâ€™s a full execution engine with state, tools, UI, telemetry, and context management â€” all connecting to Anthropicâ€™s API.

ğŸ”¹ Design decisions come from real failure modes

Tool guardrails, state usage, token budgets, and structured messages werenâ€™t theoretical â€” they fixed real problems discovered while reverse engineering.

ğŸ”¹ Claude Codeâ€™s lessons generalize

The article likely ends with patterns you can use to build your own reliable agentic assistant â€” not just use Claude Code.

ğŸ“Œ Why You Canâ€™t Get Full Verbatim

Because:

The article is behind Mediumâ€™s member paywall.

Only a limited preview (about 100 lines) is available publicly.

If You Wantâ€¦

I can provide any of the following from this topic:

ğŸ”¹ A full section-by-section summary of all 15 parts of the Claude Code internals series
ğŸ”¹ A technical architecture diagram or flowchart
ğŸ”¹ A comparison with other coding agents (e.g., GitHub Copilot, CodeLlama agents)
ğŸ”¹ A tutorial on building your own LLM coding agent using these patterns

Just tell me the format you want!




1ï¸âƒ£ What Claude Code is (mental model)

Claude Code = Local Agent Orchestrator + Claude API

Think of it as:

A local autonomous coding agent that:

Reads your repo

Maintains working memory

Uses tools (shell, git, file ops)

Delegates work to sub-agents

Talks to Claude models via Anthropic API

System Design 
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Developer       â”‚
â”‚  (Terminal / Editor)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Claude Code CLI   â”‚
â”‚  (~/.local/bin/claude) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Claude Code Runtime             â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Context Mgr  â”‚  â”‚ Instruction Mgr â”‚ â”‚
â”‚  â”‚ (repo scan)  â”‚  â”‚ (CLAUDE.md)     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         â”‚                     â”‚         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Memory Engine â”‚  â”‚ Agent Planner  â”‚ â”‚
â”‚  â”‚ (session)     â”‚  â”‚ (task split)   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         â”‚                     â”‚         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚         â”‚
â”‚  â”‚   Tool Executor     â”‚â—„â”€â”€â”€â”€â”€â”˜         â”‚
â”‚  â”‚ (shell, git, fs)   â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Anthropic Claude API     â”‚
â”‚  (Sonnet / Opus / Haiku)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 2: Repo context ingestion

Claude Code:

Detects git root

Scans:

Directory tree

Key files (README, pyproject, package.json)

Language markers

Context Sources:
- File names
- Folder structure
- Important configs
- Recently modified files

Step 3: Instruction resolution (CLAUDE.md)
CLAUDE.md (repo root)
.claude/CLAUDE.md
.claude/agents/*.md

Command prompt
â†“
CLAUDE.md
â†“
Agent instructions
â†“
Default system prompt

Step 4: Context engineering (critical)

SYSTEM:
You are Claude Code, an autonomous coding agent...

DEVELOPER:
[CLAUDE.md rules]

MEMORY:
[session summary]

REPO CONTEXT:
[file summaries]

USER:
Refactor repo...

Step 5: Agent planning phase
Task â†’ Subtasks â†’ Tool needs â†’ Agent assignment
1. Understand repo structure
2. Identify anti-patterns
3. Refactor API layer
4. Update tests

Sub-agent architecture (very important)
Claude Code uses virtual sub-agents (not OS processes).

Main Agent (Orchestrator)
â”‚
â”œâ”€ CodeReader Agent
â”‚   â””â”€ Reads & summarizes files
â”‚
â”œâ”€ Refactor Agent
â”‚   â””â”€ Proposes code changes
â”‚
â”œâ”€ Test Agent
â”‚   â””â”€ Updates / creates tests
â”‚
â””â”€ Validator Agent
    â””â”€ Runs tools & verifies

Sub-agents = prompt-scoped role specialization, not separate models

Tool execution flow
Claude â†’ Tool Call â†’ CLI Runtime â†’ OS

Claude: "Run tests"
â†“
Tool Executor
â†“
shell: pytest
â†“
stdout â†’ Claude


Tools available locally

shell

git

file read/write

diff

search (ripgrep)

ğŸ”’ All tools run locally, not on Anthropic servers



Memory handling (session + working memory)
Types of memory
1. Short-term (turn memory)

Current prompt window

Recent tool outputs

2. Session memory

Stored in:

~/.local/share/claude/

Contains:

Task summaries

Decisions

High-level plan state


3. Instruction memory

Persistent via CLAUDE.md

Claude summarizes old context instead of replaying full logs




.claude/
â”œâ”€ CLAUDE.md
â”œâ”€ agents/
â”‚  â”œâ”€ refactor.md
â”‚  â”œâ”€ reviewer.md
â”‚  â””â”€ tester.md
â”œâ”€ tools.json
â””â”€ memory/
   â””â”€ session-summary.json


Context pruning & token management

Claude Code:

Scores files by relevance

Summarizes large files

Drops low-signal content

Maintains semantic continuity

This is similar to hierarchical RAG, but file-based.




User
 â”‚
 â–¼
CLI Command
 â”‚
 â–¼
Context Builder
 â”‚
 â”œâ”€ Repo Scan
 â”œâ”€ CLAUDE.md
 â”œâ”€ Session Memory
 â”‚
 â–¼
Agent Planner
 â”‚
 â”œâ”€ Task Decomposition
 â”œâ”€ Sub-agent Roles
 â”‚
 â–¼
Claude Model
 â”‚
 â”œâ”€ Reasoning
 â”œâ”€ Tool Decisions
 â”‚
 â–¼
Tool Executor
 â”‚
 â”œâ”€ Shell
 â”œâ”€ Git
 â”œâ”€ FS
 â”‚
 â–¼
Result Validator
 â”‚
 â–¼
User Output





ğŸ”Ÿ How this maps to Agentic RAG (your domain)
Claude Code	Agentic RAG Equivalent
Repo scan	Vector retrieval
CLAUDE.md	System prompt
Sub-agents	Role-based agents
Tool calls	Function calling
Memory summaries	Long-term memory
Planner	Agent controller







Reference 
https://code.claude.com/docs/en/sub-agents
https://code.claude.com/docs/en/agent-teams
https://agents.md/
https://code.claude.com/docs/en/how-claude-code-works
https://kotrotsos.medium.com/claude-code-internals-lessons-learned-and-whats-next-551092abeb5d

https://kotrotsos.medium.com/claude-code-internals-lessons-learned-and-whats-next-551092abeb5d
https://kotrotsos.medium.com/claude-code-internals-part-11-terminal-ui-542fe17db016
https://kotrotsos.medium.com/claude-code-internals-part-6-session-state-management-e729f49c8bb9?utm_source=chatgpt.com
https://kotrotsos.medium.com/claude-code-internals-part-2-the-agent-loop-5b3977640894
https://www.linkedin.com/posts/kotrotsos_claude-code-internals-part-1-high-level-activity-7412050007668969472-NM5f?utm_source=chatgpt.com
https://kotrotsos.medium.com/claude-code-internals-part-3-message-structure-d56172049973?utm_source=chatgpt.com
https://kotrotsos.medium.com/claude-code-internals-part-5-tools-reference-d7c9c50eb779?utm_source=chatgpt.com
https://kotrotsos.medium.com/claude-code-internals-part-13-context-management-ffa3f4a0f6b4
https://kotrotsos.medium.com/claude-code-internals-part-1-high-level-architecture-9881c68c799f
https://archive.ph/2026.01.12-212408/https%3A/kotrotsos.medium.com/claude-code-internals-part-11-terminal-ui-542fe17db016?utm_source=chatgpt.com
https://muneebdev.com/claude-code-best-practices-500k-lines/?utm_source=chatgpt.com
https://muneebdev.com/claude-code-best-practices-500k-lines/?utm_source=chatgpt.com
https://kotrotsos.medium.com/claude-code-internals-lessons-learned-and-whats-next-551092abeb5d
https://blog.devgenius.io/context-is-the-new-skill-lessons-from-the-claude-code-best-practices-guide-3d27c2b2f1d8
https://medium.com/%40kapilkumar080/claude-code-in-production-real-engineering-use-cases-challenges-solved-and-lessons-learned-4ee2b06b739b
https://kotrotsos.medium.com/claude-code-internals-part-12-request-lifecycle-fe3cef711f81
https://lukasniessen.medium.com/claude-code-in-production-from-basics-to-building-real-systems-0a9995bafcef
https://www.reidbarber.com/blog/reverse-engineering-claude-code?utm_source=chatgpt.com
https://pub.towardsai.net/mastering-claude-code-the-ultimate-guide-to-ai-powered-development-afccf1bdbd5b
https://nielsberglund.com/post/2026-01-11-interesting-stuff---week-02-2026/?utm_source=chatgpt.com
https://blog.devgenius.io/the-definitive-guide-to-claude-code-from-first-install-to-production-workflows-6d37a6d33e40?utm_source=chatgpt.com
https://blog.devgenius.io/superpowers-explained-the-claude-plugin-that-enforces-tdd-subagents-and-planning-c7fe698c3b82
https://www.sabrina.dev/p/reverse-engineering-claude-code-using?utm_source=chatgpt.com
https://ai.plainenglish.io/claude-codes-open-source-code-simplifier-the-ai-fix-for-the-mess-ai-creates-46aee47be244
https://www.youtube.com/watch?v=i0P56Pm1Q3U&utm_source=chatgpt.com
https://levelup.gitconnected.com/reverse-engineering-claude-code-how-skills-different-from-agents-commands-and-styles-b94f8c8f9245?utm_source=chatgpt.com
https://blog.gopenai.com/the-claude-developer-guide-in-python-agent-skills-9ff0544b51d6
https://lilys.ai/en/notes/design-with-canva-20251118/inside-claude-code-engineers
https://cc.deeptoai.com/docs/en/advanced/claude-code-reverse-analysis?utm_source=chatgpt.com
https://generativeai.pub/the-only-claude-md-482b771431b2
https://developertoolkit.ai/en/claude-code/lessons/architecture/?utm_source=chatgpt.com - event driven architecture 

Grafana
https://enverus.grafana.net/explore?schemaVersion=1&panes=%7B%229tz%22%3A%7B%22datasource%22%3A%22grafanacloud-logs%22%2C%22queries%22%3A%5B%7B%22datasource%22%3A%7B%22type%22%3A%22loki%22%2C%22uid%22%3A%22grafanacloud-logs%22%7D%2C%22direction%22%3A%22backward%22%2C%22editorMode%22%3A%22code%22%2C%22expr%22%3A%22%7Bcluster%3D%5C%22genai-dev-ue1-mu%5C%22%2C+container%3D%5C%22genai-instant-analyst-api%5C%22%2C+namespace%3D%5C%22genai-genai-ia-api-dev%5C%22%7D%5Cn%23+%7C%3D+%60Completed+execution+-+Agent+ID%3A+%27entity-extraction%27%60%5Cn%23+%7C%3D+%60retriever+took+longer+than%60+%7C%3D+%60e561dea76877%60+%5Cn%23+%7C%3D+%60%28retry+%23%60+%5Cn%23+%7C%3D+%60e561dea76877%60+%23%7C%3D+%60retriever%5D+Original+attempt+%280%29+fai%60%5Cn%23+%7C%7E+%5C%22Vector+store+search+complete%7CReranking+completed+in%7CDuration+for+team%7CDuration+in+seconds%7CCompleted+execution+-+Agent+ID%5C%22%5Cn%23+%7C%7E+%5C%22Vector+store+search+complete%5C%22%22%2C%22queryType%22%3A%22range%22%2C%22refId%22%3A%22A%22%7D%5D%2C%22range%22%3A%7B%22from%22%3A%221769558790559%22%2C%22to%22%3A%221769562390559%22%7D%2C%22panelsState%22%3A%7B%22logs%22%3A%7B%22id%22%3A%22A_1769562383211714526_72f9ea4e%22%2C%22visualisationType%22%3A%22logs%22%2C%22sortOrder%22%3A%22Descending%22%7D%7D%2C%22compact%22%3Afalse%7D%7D&orgId=1
