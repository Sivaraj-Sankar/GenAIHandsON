MVC Architecture - Model View Controller 

Modern Software Design [process, data, itegration, deployment]
Choosing Tech Stack 
Choosing Tools that support by Tech Stack

Monolithic[Spring Boot, .NET Core, Rails] = All Functionality in a single deployable unit. --> Legacy Systems, simplicity, fast iteration, no inter-process communication
                                                            --> Hard to Scale, single point of failure, long deployment cycles. 

Layered (N-tier)[JEE, ASP.NET MVC, Spring MVC]  = Functional Layers (UI -> Service -> DAO -> DB). --> | classic Enterprise apps, clear separation of concerns, easy to understand, modular-testing
                                                                                                      | Over-Engineering, tight coupling between layers if not disciplined. 


Client-Server/Thin-Client[REST, gRPC, GraphQL]    Dedicated Server serve data --> clients consume via API or UI, --> webapps, desktop clients, mobile backends, | centralised control, straightforward security model
                                                                                             --> Network Latency, single server bottleneck

Microkernel (Plug-in) [OSGi, Eclipse RCP, Netty Extensions]    --> Core Engine + Pluggable modules, |IDEs, OS Kernels, modular business apps, 
                                                               --> Extendable without recompilation, isolation. | Versioning of plugins, risk of core-module mismatch. 
                                                               --> 

Microservices[Docker + Kubernetes, Istio, Spring Cloud]      --> Each service owns a bounded context, services communicate over network usually(HTTP/REST or message bus)
                   --> Large Evolving systems, CI/CD Pipelines, polyglot teams, Independent deployment, fault isolation. language flexibility, Distributed transaction complexity, network overhead, ops burden

Service‚ÄëOriented Architecture (SOA)[Apache CXF, WSO2, MuleSoft] - Reusable services exposed via contracts (WSDL, REST).Enterprise integration, on‚Äëprem legacy systems, Reusability, governance.
                                    -> Heavyweight protocols, slow service contracts, coupling through a shared service bus.

**Event‚ÄëDriven Architecture (EDA)[Kafka, RabbitMQ, Azure Event Grid] --> Decoupled components react to events on a publish/subscribe channel.
                                      Real‚Äëtime dashboards, IoT backends, loosely coupled workflows.
                                      High scalability, natural async patterns, easy to add new consumers
                                      Event ordering guarantees,
                                      event storming‚Äù overhead, debugging difficulty.

**Message‚ÄëDriven / Message‚ÄëQueue**[ActiveMQ, Amazon SQS, Kafka] --> Tasks are serialized into messages that are queued and processed asynchronously.
                                   --> Background jobs, batch pipelines, order processing. | Asynchronous flow, decoupling of producer/consumer.
                                   --> Potential message loss if not idempotent, latency.


Saga / Orchestration[Temporal, Zeebe, Netflix Conductor]                 ----> Long‚Äërunning distributed transactions broken into compensating actions.
                                           Order‚Äëfulfillment, booking systems, micro‚Äëservice workflows.
                                           Consistency without distributed ACID.
                                           Complex orchestration logic, need for persistence.


Hexagonal (Ports & Adapters) / Clean / Onion[Spring Hexagonal, Micronaut, ASP.NET Clean Architecture]  --> Outer adapters plug into inner domain; business logic is isolated from frameworks.
                                              --> Domain‚Äëheavy apps, test‚Äëfirst development, maintainability.
                                              --> Clear separation, testable domain, easier migration.
                                              --> Requires discipline to keep inner layers pure

Event‚ÄëSourced [Axon, EventStore, Kafka]    ----> State is derived from an immutable stream of events
                  ----> current state is the result of replaying the stream.
                  ----> Auditable systems, finance, analytics pipelines
                  ----> Full audit trail, easy replay, time‚Äëtravel debugging.
                  ----> Event schema evolution, large storage footprint, complexity of read‚Äëmodels.

Event Sourcing Architecture 
used in software systems where state is not stored directly, but instead derived from a sequence of immutable events.
Instead of storing the current state of an object, you store a log of all the events that have happened to that object.
The current state is then reconstructed by replaying those events.



Core Components

Event

A fact that something happened in the system (e.g., UserRegistered, ProductAddedToCart, OrderShipped).

Events are immutable and timestamped.
Event Store
----------
A specialized database or log where events are saved in order.
Unlike a typical database, this is append-only.
Aggregate (or Entity)
--------------------
A business object whose state is reconstructed by replaying the sequence of events related to it.
Does not store its state persistently‚Äîstate is rebuilt on demand.
Command
-------
A request to perform an action (e.g., RegisterUser, AddItemToCart).
Commands lead to state changes which are captured as new events.
Event Handler / Projector / Read Model
--------------------------------------
Components that listen to events and update read-optimized views or external systems.
Helps in CQRS (Command Query Responsibility Segregation), where read and write models are separate.

Banking systems: Every transaction is an event
E-commerce: Order lifecycle tracked via events
Git: Commits are events; state is built from history

Financial systems
Auditable systems
Collaborative apps
Domain-driven systems

Poor Use case for Event Sourcing 
System Requires Strong ACID 


Advantages:
Auditing / Traceability: Full history of all changes
Debugging & Replay: You can "replay" events to recreate bugs or recover state
Scalability: Works well with CQRS and microservices
Flexibility: You can build different views of the data from the same event log

‚ùå Challenges:
Complexity: Harder to reason about than CRUD
Event versioning: Updating old events when your data model changes
Eventual consistency: Read models may not be up-to-date instantly
Storage: Event logs can grow large


Flow Example

Command is sent: CreateOrder
Command handler validates and creates a new event: OrderCreated
Event is saved to the event store
Aggregate replays events to reconstruct current state
Event is dispatched to event handlers, which update read models or trigger side effects (like sending an email)

intuitive at the beginning because it's very different from traditional database-driven design.
---------------
Start With a Real-World Analogy: Banking Ledger
---------------------
Imagine you're a bank.
You never just store the current balance of a bank account in real life.
Instead, you store a list of all transactions (deposits and withdrawals), and the current balance is calculated by adding them up.

That‚Äôs event sourcing.
Each transaction is an event.

You're not saving the balance directly (the state). You're saving every event that led to it, so you can always:

Go back in time and check what happened
Recalculate balances if needed
Audit for fraud or errors

Now, Intuitively Understand the Flow
Let's walk through this again, but now with WHY behind each step:


Event 
Event Store 
Aggregate (or Entity) 
Command 
Event Handler/Projector/Read Model 

1. Command is sent: CreateOrder
In traditional systems, this might directly write to the database.
But in event sourcing, we don't change state immediately.
2.Command handler validates and creates a new event: OrderCreated
If valid, we record the fact: "An order WAS created."
This is now an event ‚Äì a historical fact.
3.Event is saved to the event store
üì¶ We store this immutable fact ‚Äî forever.
Now we have a permanent record.
We‚Äôre building a timeline of what happened ‚Äî just like a transaction log.
4.Aggregate replays events to reconstruct current state
To know the current state of an order, we replay its event history.

E.g., if an order has these events:
OrderCreated
ItemAdded
OrderConfirmed
We replay them to know its state: items in cart, status = confirmed.
5.Event is dispatched to event handlers, which update read models or trigger side effects
Now we notify other parts of the system: "Hey, something happened."
Maybe we update a read model (e.g., list of user orders).
Maybe we send an email confirmation.
Maybe we update analytics.

1. Full History (Auditability) - You can rebuild any past state [Invaluable for financial, legal, or regulated systems.]
2. Debugging & Replay [You can replay the whole system and see where it broke.]
Reproduce bugs exactly as they happened.
Recalculate state from scratch.
3. Scalable Read Models (CQRS)
Separate read models from write logic:
Reads are fast, denormalized, and can be optimized per use case.
Writes are clean, consistent, and business-driven.

4.Flexible Side Effects
When an event happens, you can:
Send emails
Update search indexes
Notify other systems
All decoupled, without changing core logic.

5.Business Logic Mirrors the Real World
Users don't think in terms of "records"; they think in actions:
"I placed an order"
"I changed my address"
"I canceled the subscription"

Event sourcing mirrors this mental model.
Because it‚Äôs more complex to implement and maintain:
Requires event versioning when your data model evolves.
Harder to query without read models.
Requires thinking in events, which is not natural for many developers.

Use Event Sourcing if:
You need an audit trail or history
You want to replay or analyze past events
You have complex business workflows
You're building a distributed or microservices system
You want CQRS or event-driven architectures
Avoid it if your app is just simple CRUD (like a to-do list or blog).


------
Command‚ÄëQuery Responsibility Segregation (CQRS) [Axon, NServiceBus, Spring Data] - Separate read and write models; often combined with event sourcing.
                                                - Systems with heavy read‚Äëload or complex queries (e.g., analytics).
                                                - Optimised queries, scaling reads independently.
                                                - Duplication of data, consistency challenges.

Reactive / Event‚ÄëLoop[Project Reactor, RxJava, Akka Streams, Vert.x] --> Non‚Äëblocking, back‚Äëpressure aware streams;
                      --> often built on the Reactive Streams spec.
                      --> High‚Äëthroughput real‚Äëtime services, IoT, streaming pipelines.
                      --> Handles many concurrent connections, better resource utilisation.
                      --> Steep learning curve, debugging async flows can be hard.

Serverless / FaaS [AWS Lambda, Azure Functions, Google Cloud Functions]---> Stateless functions run in response to events.
                       billing per invocation.
                       Event‚Äëdriven micro‚Äëtasks, short‚Äëlived compute.
                       variable load.
                       No server management, auto‚Äëscaling, cost‚Äëefficient for sporadic load.
                       Cold‚Äëstart latency, vendor lock‚Äëin, statefulness requires external stores.

Event‚ÄëDriven (within a microservice) [Kafka, NATS, Pulsar] --> Services publish domain events;
                                         other services react (pub/sub) to them
                                         Highly decoupled integrations, real‚Äëtime dashboards, analytics
                                         Loose coupling, easy to add new consumers
                                         Event flooding, versioning of event schemas, debugging

Multi‚Äëtenant / SaaS [Salesforce, Stripe, multi‚Äëtenant DB schemas]  --> Shared infrastructure but tenant‚Äëisolated data, SaaS platforms, shared APIs.
                      --> Cost sharing, quick onboarding of new tenants.
                      --> Security boundaries, resource contention, tenant‚Äëspecific customisation.


Component‚ÄëBased - Self‚Äëcontained components that can be reused or swapped (often used for UI).
                - Front‚Äëend libraries, UI frameworks. | Reusability, independent release cycles.
                - Inconsistent API contracts, integration friction.
                - React Components, Vue, Web Components

‚Ä¢ *Need fast time‚Äëto‚Äëmarket and a single team? Monolith or layered.  
>  ‚Ä¢ *Have a rapidly evolving, large code‚Äëbase? Microservices or SOA.  
>  ‚Ä¢ *Want event‚Äëdriven real‚Äëtime flow? EDA + reactive patterns.  
>  ‚Ä¢ *Need on‚Äëprem, strongly governed services? SOA or micro‚Äëkernel.*




                       

                       







