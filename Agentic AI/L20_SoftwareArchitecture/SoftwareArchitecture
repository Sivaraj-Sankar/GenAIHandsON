Different Architecture 
Event Sourcing Detailed Comment
Push/Pull 
DDD Domain Driven Architecture - DDD 
MVC = MTV
AI Architecture 
SOLID 
KISS
DRY 
HLD
LLD
ACID
BASE
Distributed System
Orcale 
Design Patterns Cheat Sheet 







MVC Architecture - Model View Controller 

Modern Software Design [process, data, itegration, deployment]
Choosing Tech Stack 
Choosing Tools that support by Tech Stack

Monolithic[Spring Boot, .NET Core, Rails] = All Functionality in a single deployable unit. --> Legacy Systems, simplicity, fast iteration, no inter-process communication
                                                            --> Hard to Scale, single point of failure, long deployment cycles. 

Layered (N-tier)[JEE, ASP.NET MVC, Spring MVC]  = Functional Layers (UI -> Service -> DAO -> DB). --> | classic Enterprise apps, clear separation of concerns, easy to understand, modular-testing
                                                                                                      | Over-Engineering, tight coupling between layers if not disciplined. 


Client-Server/Thin-Client[REST, gRPC, GraphQL]    Dedicated Server serve data --> clients consume via API or UI, --> webapps, desktop clients, mobile backends, | centralised control, straightforward security model
                                                                                             --> Network Latency, single server bottleneck

Microkernel (Plug-in) [OSGi, Eclipse RCP, Netty Extensions]    --> Core Engine + Pluggable modules, |IDEs, OS Kernels, modular business apps, 
                                                               --> Extendable without recompilation, isolation. | Versioning of plugins, risk of core-module mismatch. 
                                                               --> 

Microservices[Docker + Kubernetes, Istio, Spring Cloud]      --> Each service owns a bounded context, services communicate over network usually(HTTP/REST or message bus)
                   --> Large Evolving systems, CI/CD Pipelines, polyglot teams, Independent deployment, fault isolation. language flexibility, Distributed transaction complexity, network overhead, ops burden

Service‚ÄëOriented Architecture (SOA)[Apache CXF, WSO2, MuleSoft] - Reusable services exposed via contracts (WSDL, REST).Enterprise integration, on‚Äëprem legacy systems, Reusability, governance.
                                    -> Heavyweight protocols, slow service contracts, coupling through a shared service bus.

**Event‚ÄëDriven Architecture (EDA)[Kafka, RabbitMQ, Azure Event Grid] --> Decoupled components react to events on a publish/subscribe channel.
                                      Real‚Äëtime dashboards, IoT backends, loosely coupled workflows.
                                      High scalability, natural async patterns, easy to add new consumers
                                      Event ordering guarantees,
                                      event storming‚Äù overhead, debugging difficulty.

**Message‚ÄëDriven / Message‚ÄëQueue**[ActiveMQ, Amazon SQS, Kafka] --> Tasks are serialized into messages that are queued and processed asynchronously.
                                   --> Background jobs, batch pipelines, order processing. | Asynchronous flow, decoupling of producer/consumer.
                                   --> Potential message loss if not idempotent, latency.


Saga / Orchestration[Temporal, Zeebe, Netflix Conductor]                 ----> Long‚Äërunning distributed transactions broken into compensating actions.
                                           Order‚Äëfulfillment, booking systems, micro‚Äëservice workflows.
                                           Consistency without distributed ACID.
                                           Complex orchestration logic, need for persistence.


Hexagonal (Ports & Adapters) / Clean / Onion[Spring Hexagonal, Micronaut, ASP.NET Clean Architecture]  --> Outer adapters plug into inner domain; business logic is isolated from frameworks.
                                              --> Domain‚Äëheavy apps, test‚Äëfirst development, maintainability.
                                              --> Clear separation, testable domain, easier migration.
                                              --> Requires discipline to keep inner layers pure

Event‚ÄëSourced [Axon, EventStore, Kafka]    ----> State is derived from an immutable stream of events
                  ----> current state is the result of replaying the stream.
                  ----> Auditable systems, finance, analytics pipelines
                  ----> Full audit trail, easy replay, time‚Äëtravel debugging.
                  ----> Event schema evolution, large storage footprint, complexity of read‚Äëmodels.

Event Sourcing Architecture 
used in software systems where state is not stored directly, but instead derived from a sequence of immutable events.
Instead of storing the current state of an object, you store a log of all the events that have happened to that object.
The current state is then reconstructed by replaying those events.



Core Components

Event

A fact that something happened in the system (e.g., UserRegistered, ProductAddedToCart, OrderShipped).

Events are immutable and timestamped.
Event Store
----------
A specialized database or log where events are saved in order.
Unlike a typical database, this is append-only.
Aggregate (or Entity)
--------------------
A business object whose state is reconstructed by replaying the sequence of events related to it.
Does not store its state persistently‚Äîstate is rebuilt on demand.
Command
-------
A request to perform an action (e.g., RegisterUser, AddItemToCart).
Commands lead to state changes which are captured as new events.
Event Handler / Projector / Read Model
--------------------------------------
Components that listen to events and update read-optimized views or external systems.
Helps in CQRS (Command Query Responsibility Segregation), where read and write models are separate.

Banking systems: Every transaction is an event
E-commerce: Order lifecycle tracked via events
Git: Commits are events; state is built from history

Financial systems
Auditable systems
Collaborative apps
Domain-driven systems

Poor Use case for Event Sourcing 
System Requires Strong ACID 


Advantages:
Auditing / Traceability: Full history of all changes
Debugging & Replay: You can "replay" events to recreate bugs or recover state
Scalability: Works well with CQRS and microservices
Flexibility: You can build different views of the data from the same event log

‚ùå Challenges:
Complexity: Harder to reason about than CRUD
Event versioning: Updating old events when your data model changes
Eventual consistency: Read models may not be up-to-date instantly
Storage: Event logs can grow large


Flow Example

Command is sent: CreateOrder
Command handler validates and creates a new event: OrderCreated
Event is saved to the event store
Aggregate replays events to reconstruct current state
Event is dispatched to event handlers, which update read models or trigger side effects (like sending an email)

intuitive at the beginning because it's very different from traditional database-driven design.
---------------
Start With a Real-World Analogy: Banking Ledger
---------------------
Imagine you're a bank.
You never just store the current balance of a bank account in real life.
Instead, you store a list of all transactions (deposits and withdrawals), and the current balance is calculated by adding them up.

That‚Äôs event sourcing.
Each transaction is an event.

You're not saving the balance directly (the state). You're saving every event that led to it, so you can always:

Go back in time and check what happened
Recalculate balances if needed
Audit for fraud or errors

Now, Intuitively Understand the Flow
Let's walk through this again, but now with WHY behind each step:


Event 
Event Store 
Aggregate (or Entity) 
Command 
Event Handler/Projector/Read Model 

1. Command is sent: CreateOrder
In traditional systems, this might directly write to the database.
But in event sourcing, we don't change state immediately.
2.Command handler validates and creates a new event: OrderCreated
If valid, we record the fact: "An order WAS created."
This is now an event ‚Äì a historical fact.
3.Event is saved to the event store
üì¶ We store this immutable fact ‚Äî forever.
Now we have a permanent record.
We‚Äôre building a timeline of what happened ‚Äî just like a transaction log.
4.Aggregate replays events to reconstruct current state
To know the current state of an order, we replay its event history.

E.g., if an order has these events:
OrderCreated
ItemAdded
OrderConfirmed
We replay them to know its state: items in cart, status = confirmed.
5.Event is dispatched to event handlers, which update read models or trigger side effects
Now we notify other parts of the system: "Hey, something happened."
Maybe we update a read model (e.g., list of user orders).
Maybe we send an email confirmation.
Maybe we update analytics.

1. Full History (Auditability) - You can rebuild any past state [Invaluable for financial, legal, or regulated systems.]
2. Debugging & Replay [You can replay the whole system and see where it broke.]
Reproduce bugs exactly as they happened.
Recalculate state from scratch.
3. Scalable Read Models (CQRS)
Separate read models from write logic:
Reads are fast, denormalized, and can be optimized per use case.
Writes are clean, consistent, and business-driven.

4.Flexible Side Effects
When an event happens, you can:
Send emails
Update search indexes
Notify other systems
All decoupled, without changing core logic.

5.Business Logic Mirrors the Real World
Users don't think in terms of "records"; they think in actions:
"I placed an order"
"I changed my address"
"I canceled the subscription"

Event sourcing mirrors this mental model.
Because it‚Äôs more complex to implement and maintain:
Requires event versioning when your data model evolves.
Harder to query without read models.
Requires thinking in events, which is not natural for many developers.

Use Event Sourcing if:
You need an audit trail or history
You want to replay or analyze past events
You have complex business workflows
You're building a distributed or microservices system
You want CQRS or event-driven architectures
Avoid it if your app is just simple CRUD (like a to-do list or blog).


------
Command‚ÄëQuery Responsibility Segregation (CQRS) [Axon, NServiceBus, Spring Data] - Separate read and write models; often combined with event sourcing.
                                                - Systems with heavy read‚Äëload or complex queries (e.g., analytics).
                                                - Optimised queries, scaling reads independently.
                                                - Duplication of data, consistency challenges.

Reactive / Event‚ÄëLoop[Project Reactor, RxJava, Akka Streams, Vert.x] --> Non‚Äëblocking, back‚Äëpressure aware streams;
                      --> often built on the Reactive Streams spec.
                      --> High‚Äëthroughput real‚Äëtime services, IoT, streaming pipelines.
                      --> Handles many concurrent connections, better resource utilisation.
                      --> Steep learning curve, debugging async flows can be hard.

Serverless / FaaS [AWS Lambda, Azure Functions, Google Cloud Functions]---> Stateless functions run in response to events.
                       billing per invocation.
                       Event‚Äëdriven micro‚Äëtasks, short‚Äëlived compute.
                       variable load.
                       No server management, auto‚Äëscaling, cost‚Äëefficient for sporadic load.
                       Cold‚Äëstart latency, vendor lock‚Äëin, statefulness requires external stores.

Event‚ÄëDriven (within a microservice) [Kafka, NATS, Pulsar] --> Services publish domain events;
                                         other services react (pub/sub) to them
                                         Highly decoupled integrations, real‚Äëtime dashboards, analytics
                                         Loose coupling, easy to add new consumers
                                         Event flooding, versioning of event schemas, debugging

Multi‚Äëtenant / SaaS [Salesforce, Stripe, multi‚Äëtenant DB schemas]  --> Shared infrastructure but tenant‚Äëisolated data, SaaS platforms, shared APIs.
                      --> Cost sharing, quick onboarding of new tenants.
                      --> Security boundaries, resource contention, tenant‚Äëspecific customisation.


Component‚ÄëBased - Self‚Äëcontained components that can be reused or swapped (often used for UI).
                - Front‚Äëend libraries, UI frameworks. | Reusability, independent release cycles.
                - Inconsistent API contracts, integration friction.
                - React Components, Vue, Web Components

‚Ä¢ *Need fast time‚Äëto‚Äëmarket and a single team? Monolith or layered.  
>  ‚Ä¢ *Have a rapidly evolving, large code‚Äëbase? Microservices or SOA.  
>  ‚Ä¢ *Want event‚Äëdriven real‚Äëtime flow? EDA + reactive patterns.  
>  ‚Ä¢ *Need on‚Äëprem, strongly governed services? SOA or micro‚Äëkernel.*

Push/Pull 
--------- 
API's
Push: A webhook sends data to your app when something happens (e.g., Stripe sends payment info when a payment is made).
Pull: Your app periodically calls (polls) an API to ask if something changed

Data Synchronization
Push: A server sends real-time updates to clients (e.g., chat messages in WhatsApp).
Pull: A client regularly checks the server for new messages.

Build Systems / CI/CD
Push-based triggers: When code is pushed, the pipeline runs automatically.
Pull-based triggers: The CI system polls the repo for changes at intervals.

Messaging Systems
Push: A message broker (like Kafka) pushes data to subscribers.
Pull: Consumers pull messages from the queue when they're ready.

Push & Pull in Computing 
processor architecture, memory management, data pipelines, and parallel computing
Streaming, event-driven systems, GPUs (some cases) - Push 
Polling, lazy evaluation, demand-driven systems - Pull

Push-based dataflow: Data is pushed through the pipeline as it becomes available.
E.g., Reactive programming (RxJS, Reactive Streams)

Dataflow / Stream Processing
Pull-based dataflow: Downstream components pull data when ready.
E.g., Iterators or generators in Python/JavaScript.

Push = Event streams
Pull = Iterators / lazy evaluation

Caches & Memory Hierarchies
Push: A system writes (pushes) data proactively to cache or memory (e.g., write-through cache).
Pull: A component requests (pulls) data when it's not available locally (e.g., cache miss triggers memory fetch).



-----------------------
Domain Driven Design  (DDD) approach in your architecture 

1.DDD is not a ‚Äúnew architecture‚Äù per se‚Äî
2.it is a set of principles and patterns that help you model [complex business domains] in code. 
3.The benefits translate into multiple layers of the architecture

Model the true business problem                                                                                            Patterns
------------------------------
Domain model captures real concepts (aggregates, entities, value objects). [Domain‚Äëcentric layers (hexagonal, clean).] -    Domain‚Äëevent, repository, service objects

Make the domain testable
-----------------------
Business logic lives in pure, side‚Äëeffect‚Äëfree code. [Domain‚Äëonly layer; outer frameworks are adapters] --->                TDD, unit tests for domain

Encourage clear boundaries
-------------------------
Bounded contexts isolate different areas of the domain [Multiple bounded contexts as separate services or modules.]       CQRS, EDA for inter‚Äëbounded‚Äëcontext communication.

Provide an audit trail
----------------------
State is derived from events, not overwritten   [Event‚Äësourced systems]                                                   [Event‚Äësource, read‚Äëmodel projection]


Scale reads and writes independently
------------------------------------
Separate read/write concerns.                  [CQRS or read‚Äëmodel services]                                              Separate database schemas, query optimization

Enable real‚Äëtime reaction
-------------------------
Publish events whenever something happens      EDA, reactive streams                                                       Kafka, message brokers, asynchronous handlers. |


Facilitate continuous delivery
------------------------------  
Domain logic is decoupled from infrastructure        [Clean/hexagonal architecture]                                     Inversion of control, DI containers.


When should you adopt DDD
1. **High domain complexity** ‚Äì if your business logic is non‚Äëtrivial, multiple entities, and heavy business rules.
2. **Long‚Äëterm maintainability** ‚Äì you expect the system to evolve over time and want to isolate change.
3. **Multiple developers/teams** ‚Äì you need clear boundaries and governance so teams can work independently.
4. **Need for deep insight and auditability** ‚Äì event sourcing gives you a natural audit trail.

When can you skip it?**
- **Simple CRUD apps** or where the domain logic is trivial ‚Äì a CRUD‚Äëonly architecture (e.g., ‚ÄúCRUD‚Äëonly microservices‚Äù or ‚Äúserverless CRUD‚Äù) may be more efficient.
- **Very small teams** where learning DDD‚Äôs patterns adds overhead faster than it brings benefits.
- **Performance‚Äëcritical, stateful services** where pure DDD‚Äôs separation might add latency (unless combined with caching or read‚Äëmodels).

**Architectural options for ‚ÄúDomain-Driven‚Äù services**
1.Domain‚ÄëDriven + Microservices

| **Option** | **Description** | **Typical Stack** | **Pros** | **Cons** |
|-----------|-----------------|-------------------|----------|----------|
| **DDD + EDA** | Each microservice owns its domain model and publishes events. Other services react. | Spring Boot (Hexagonal) + Kafka, Akka | Loose coupling, clear event flow, scalability. | Event storming complexity, need for event schema governance. |
| **DDD + CQRS** | Separate command and query services per bounded context. | Axon framework, Spring Data, EventStore | Optimised reads, easy scaling. | Complexity of maintaining two models; consistency. |
| **DDD + Event Sourcing** | Persist state as events; read‚Äëmodels projected separately. | Axon, EventStore, Kafka | Audit trail, ability to replay. | Event schema evolution; larger storage cost. |
| **DDD + Clean Architecture** | Keep domain pure; infrastructure (Spring MVC, JPA) plugs in as adapters. | Spring Hexagonal, Micronaut | Testable domain, easier migrations. | Requires discipline, can increase boilerplate. |
| **DDD + Serverless** | Domain logic runs in functions; events trigger actions. | AWS Lambda + Step Functions + DynamoDB | Pay‚Äëper‚Äëuse, easy scaling for event bursts. | Cold starts, limited compute time, vendor lock‚Äëin. |

3.2  Choosing the right mix

| **Consideration** | **Choose** | **Why** |
|-------------------|------------|---------|
| **Synchronous business flows** | DDD + Clean / Hexagonal + Spring MVC | Keeps domain pure, simple to debug. |
| **Asynchronous or real‚Äëtime flows** | DDD + EDA (Kafka) + reactive streams | Handles high concurrency, decoupled. |
| **High read‚Äëwrite imbalance** | CQRS + event sourcing | Reads are fast and can scale. |
| **Short, stateless compute tasks** | Serverless + DDD + event‚Äëdriven | Minimal infrastructure, auto‚Äëscale. |

4.The Role of the ‚ÄúBusiness Service‚Äù and its Impact on the Architecture
What is a Business Service?
A *business service* is a component that encapsulates domain logic that cannot be naturally expressed in an entity or value object. Think of it as a *Domain Service* in DDD. In a microservice, it is typically a **stateless class** that orchestrates domain objects or coordinates multiple bounded contexts.


Business‚ÄëService‚ÄëCentric Architecture

| **Architecture** | **Components** | **How It Looks** | **When It Helps** |
|------------------|---------------|------------------|-------------------|
| **Microservice (CRUD‚Äëonly)** | REST API + CRUD service + repository | Simple CRUD, no domain model. | Small or simple domain. |
| **Microservice (DDD)** | Domain model + repository + domain service | Business rules in domain. | Complex domain, long‚Äëterm evolution. |
| **Microservice (Business‚ÄëService‚Äëonly)** | A thin service layer that uses domain objects or external services but no complex DDD concepts. | Spring Service + Spring Data | Quick to implement, still separates concerns. | Harder to evolve complex domain logic. |
| **Monolithic Service (DDD)** | All domain logic in one process, possibly with bounded contexts inside. | Spring Boot + Hexagonal | Simpler deployment. | Single point of failure, scaling may be harder. |
| **Service‚ÄëOriented (SOA)** | Business services that expose business operations as SOAP or REST endpoints. | Spring WS or Spring MVC | Legacy system integration. | Heavier protocol, more overhead. |

Impact on the architecture

| **Layer** | **DDD‚Äëcentric service** | **Non‚ÄëDDD** | **Effect** |
|-----------|------------------------|-------------|------------|
| **Presentation** | Thin adapter (e.g., REST controller). | Complex domain logic mixed in. | Easier to change UI/transport. |
| **Application** | Orchestrates domain services, uses DI. | Domain logic often in controllers. | Better separation, easier unit tests. |
| **Domain** | Pure business logic, immutable entities, value objects. | Often combined with persistence logic. | Evolves independently of tech. |
| **Infrastructure** | Adapters for persistence, messaging, etc. | Mixed with business logic. | Higher coupling, harder to swap tech. |

4. **Designing a microservice using the ‚ÄúDomain‚ÄëDriven‚Äù concept**

Let‚Äôs walk through a **step‚Äëby‚Äëstep** approach to building a domain‚Äëdriven microservice. We‚Äôll use **Java + Spring Boot** with **Hexagonal/clean architecture** as the skeleton and **Kafka** for event‚Äëdriving.  
Feel free to swap languages or frameworks if you‚Äôre in .NET, Go, Node, or others; the concepts remain.

### 4.1  Identify the Bounded Context

- **Domain**: *Order Processing* (customer orders, payments, shipping).
- **Entities**: `Order`, `LineItem`, `Address`, `Payment`.
- **Value Objects**: `Money`, `OrderStatus`.
- **Aggregates**: `Order` (root) encapsulates `LineItem` and `Payment`.


MVC = MTV (Model-Template-View) --> In a blog site, the Model would be blog posts stored in a database, the View would be the HTML page displaying posts, and the Controller would handle user actions like creating a new post.
In Django:
MVC Term	Django Term
Model	Model
View	Template
Controller	View
Model:
Manages data, business logic, and rules.
Talks to the database or other data sources.
Not concerned with how data is displayed.
View:
The UI of the application.
Presents data to the user (usually from the model).
Doesn‚Äôt contain logic about how data is fetched.
Controller:
Handles input from the user (e.g., mouse clicks, form submissions).
Updates the model and decides which view to display.
Acts as a bridge between Model and View.
MVVM (Model-View-ViewModel) --> Used in: WPF (Windows), Android (Jetpack), iOS (SwiftUI), and web frameworks like KnockoutJS.
    Components:
       Model: Same as in MVC.
       View: UI, binds to ViewModel.
       ViewModel: Holds UI logic, binds View to Model using data-binding.
       Difference: MVVM emphasizes data binding between View and ViewModel, reducing boilerplate code.
MVP (Model-View-Presenter) --> Used in: Android, .NET, some web apps.
     Components:
      Model: Business/data logic.
      View: UI (dumb, passive).
      Presenter: Handles all presentation logic, talks to Model and View.
      Difference: The Presenter controls the flow and updates the View explicitly (no data binding).


PAC (Presentation-Abstraction-Control)
Similar to MVC, but allows more modular component design.
Each component has:
Presentation: UI
Abstraction: Data and logic
Control: Coordination between the two
Used in more complex or distributed UI systems (e.g., multimedia apps).

Flux / Redux (used in React)
Used in: React (web and native), Vue, etc.
Unidirectional data flow.
Components:
Store: Holds application state.
Actions: Events describing what happened.
Reducers: Pure functions that update the state.
View: React components that render UI.
Difference: Data only flows one way, which simplifies state management.


Clean Architecture (by Uncle Bob)
Emphasizes separation of concerns via layers:
Entities: Business rules.
Use Cases / Interactors: Application-specific logic.
Interface Adapters: Presenters, Controllers.
Frameworks & Drivers: UI, DB, external systems.
Common in backend APIs and scalable systems.


Pattern	Focus	Data Flow	Typical Use
MVC	UI + Logic Separation	Two-way	Web apps
MVP	Presenter handles logic	Two-way	Android, .NET
MVVM	Data binding	Two-way	Mobile, UI-heavy apps
Flux/Redux	Centralized state, one-way	One-way	React, frontend
Clean Architecture	Layered design	Controlled	Backend, scalable systems



1. Model (M) ‚Äì The Data Layer - Think of the Model as your database structure
2. View (C in MVC) ‚Äì The Logic Layer - This is the controller part in traditional MVC. It handles user requests and talks to the model to get data.
3. Template (V in MVC) ‚Äì The UI Layer - This is what the user sees. The HTML with some dynamic data.


AI Service Architecture 
-----------------------


SOLID - Object Oriented Design OOD
----------------------------------
Scalable
Maintainable
Flexible System 
S - Single Responsibility Principle (SRP) 
1. A class/Module should have only one reason to change.
2. Each Component Should focus on one thing only. 
3. Avoid God Objects or services that do too much. 
Eg: UserService - Handling Authentication, profile management, payments, split them into AuthService, ProfileService and Payment Service
O - Open/Closed Principle (OCP) 
1. Software Entities should be open for extension but closed for modification. 
2. You should be able to add new functionality without changing existing code. 
Eg: In a Logging System, Instead of modifying Logger every time you add a new log destination (file,DB,Cloud) use an interface and implement 
    new FileLogger, DBLogger, CloudLogger.
L - Liskov Substitution Principle (LSP) 
Subtypes must be substitutable for their base types without breaking behavior. 
Derived class should honor the contracts of their base classes. 
Eg: If Bird has a fly() method, then Penguin extends Bird should not exist if penguins can't fly. it breaks expectations, 
    Instead, restructure hierarchy. 
I - Interface Segregation Principle (ISP) 
1. No Client Shoule be forced to depend on methods it does not use. 
2. Perfer smaller, more specific interfaces over a large, bloated interface. 
Example: Instead of having one Machine Interface with print(), scan(), fax(), create separate interfaces Printer, Scanner, Fax 
D - Dependency Inversion Principle (DIP) 
Depend on abstractions, not concrete implementations. 
High-level modules shouldn't depend on low-level modules, they both should depend on interfaces/abstractions. 
Eg: Instead of OrderService directly creating a MySQLDatabase, inject a Database interface so it can work with MySQL, PostgreSQL, MongoDB interchangeably. 

SOLID In System Design Context
------------------------------
Even though SOLID is more about code-level design, the mindset carries over into system design:
SRP ‚Üí Microservices: each service handles one bounded context.
OCP ‚Üí Plug-in architectures, extendable APIs.
LSP ‚Üí Consistent contracts in service interfaces.
ISP ‚Üí Lightweight APIs tailored for different clients (e.g., mobile vs web).
DIP ‚Üí Using abstractions (e.g., message queues, database interfaces) so systems can swap implementations.


SOLID is a set of object-oriented design principles that promote maintainability, scalability, and flexibility
While it‚Äôs mainly for software/code design, applying the same ideas in system design helps build clean, modular, and extensible architectures.


Software and Code Design - OOD - SOLID 
Eg: E-Commerce App
1. Single Responsibility Principle (SRP)
Each component/service should handle one responsibility only.
Instead of one giant ECommerceService, split into services:
AuthService ‚Üí Login, signup, JWT tokens
ProductService ‚Üí Catalog, product details
OrderService ‚Üí Cart, checkout, orders
PaymentService ‚Üí Payments, refunds
NotificationService ‚Üí Emails, SMS, push notifications
üëâ This makes scaling easier (e.g., scale ProductService independently during sales).
2. Open/Closed Principle (OCP)
System should be extensible without modifying existing code.
Payment flow:
Instead of hardcoding PayPal/Stripe inside PaymentService, define a PaymentGateway interface.
Add new providers (PayPal, Stripe, Razorpay, ApplePay) by implementing the interface.
PaymentService remains unchanged.
üëâ This allows new integrations without breaking old ones.
3. Liskov Substitution Principle (LSP)
Subtypes must behave consistently with base contracts.
Example: Shipping providers
ShippingProvider defines calculateShippingCost(order)
Subclasses like FedExProvider, DHLProvider, InHouseDeliveryProvider must all respect the contract.
If one provider throws ‚ÄúNotImplemented‚Äù for certain orders, it breaks LSP.
üëâ Ensures you can swap providers without unexpected behavior.
4. Interface Segregation Principle (ISP)
Clients should not depend on unused methods.
Example: Admin vs Customer APIs
Customers only need APIs like browseProducts(), placeOrder().
Admins need addProduct(), manageInventory().
Instead of one giant ECommerceAPI, create separate CustomerAPI and AdminAPI.
üëâ Prevents bloated interfaces and keeps clients lightweight.
5. Dependency Inversion Principle (DIP)
Depend on abstractions, not concrete implementations.
Example: Order service storing data
OrderService shouldn‚Äôt depend on MySQL directly.
It should depend on an abstract OrderRepository.
Implementations: MySQLOrderRepository, MongoOrderRepository, or DynamoDBOrderRepository.
üëâ This makes it easy to switch databases or introduce caching without rewriting OrderService.



Architecture Overview (SOLID Applied) 
[ Client Apps ]
      |
   [ API Gateway ]
      |
  -----------------------------
  |      |       |       |    
Auth  Product  Order  Payment  (SRP - each service has 1 job)
      |       |       |
   [DBs/Repos via Abstractions]  (DIP - no service tied to a DB)
      |
  PaymentGateway Interface (OCP - new payment methods extend, not modify)
      |
 FedEx/DHL Providers (LSP - interchangeable shipping providers)


import matplotlib.pyplot as plt

# Create figure
fig, ax = plt.subplots(figsize=(10, 6))

# Hide axes
ax.axis("off")

# Components (nodes)
components = {
    "Client Apps": (0.5, 0.95),
    "API Gateway": (0.5, 0.8),
    "Auth Service": (0.2, 0.65),
    "Product Service": (0.4, 0.65),
    "Order Service": (0.6, 0.65),
    "Payment Service": (0.8, 0.65),
    "Databases / Repositories": (0.5, 0.45),
    "Payment Gateway Interface": (0.5, 0.3),
    "Providers\n(FedEx, DHL, Razorpay, etc.)": (0.5, 0.15),
}

# Draw nodes
for name, (x, y) in components.items():
    ax.text(x, y, name, ha="center", va="center",
            bbox=dict(boxstyle="round,pad=0.4", fc="lightblue", ec="black", lw=1),
            fontsize=9)

# Connections (edges)
edges = [
    ("Client Apps", "API Gateway"),
    ("API Gateway", "Auth Service"),
    ("API Gateway", "Product Service"),
    ("API Gateway", "Order Service"),
    ("API Gateway", "Payment Service"),
    ("Order Service", "Databases / Repositories"),
    ("Product Service", "Databases / Repositories"),
    ("Payment Service", "Databases / Repositories"),
    ("Payment Service", "Payment Gateway Interface"),
    ("Payment Gateway Interface", "Providers\n(FedEx, DHL, Razorpay, etc.)"),
]

# Draw arrows
for start, end in edges:
    x1, y1 = components[start]
    x2, y2 = components[end]
    ax.annotate("",
                xy=(x2, y2+0.03 if y2 < y1 else y2-0.03),
                xytext=(x1, y1-0.03 if y1 > y2 else y1+0.03),
                arrowprops=dict(arrowstyle="->", lw=1.2))

plt.show()


KISS - Keep it Simple Stupid. - Keep it Simple and StraightForward 
------------------------------------------------------------------
It‚Äôs a software design principle that emphasizes simplicity over unnecessary complexity.
1.Systems should be designed in the simplest way possible.
2.Don‚Äôt add extra features, abstractions, or optimizations unless they are absolutely needed.
3.Complexity increases the chance of bugs, reduces readability, and makes maintenance harder.

In large-scale systems, KISS means:
Don‚Äôt build over-complicated architectures when a simpler solution works.
Example:
If a monolith is enough, don‚Äôt jump straight to microservices.
Don‚Äôt introduce Kafka + Redis + RabbitMQ if a single database queue works.
Prefer clarity and straightforwardness over clever tricks.
KISS reminds us that simplicity is power. Start simple, avoid over-engineering, and only add complexity when real requirements demand it.


**Use a monolith if traffic is low, don‚Äôt prematurely split into microservices
---------------------------------------------------------
If you do use microservices, make sure each one has single responsibility, clean interfaces, and dependency abstractions


DRY - Don't Repeat Yourself
---------------------------
1.Every piece of knowledge (logic, code, configuration) should have a single, unambiguous, authoritative representation in a system.‚Äù


Microservices
-------------
Monorepo ‚Üí Google, Facebook, Uber (they use tooling to manage huge repos).
Polyrepo ‚Üí Netflix, Amazon (microservices are owned by independent teams).

Option 1: One Repo (Monorepo)
All microservices live inside a single code repository.
‚úÖ Pros
Easier dependency management ‚Üí shared libraries/utilities in one place.
Atomic commits ‚Üí changes across multiple services can be committed together.
Consistent tooling ‚Üí same linting, testing, CI/CD pipelines.
Simpler onboarding ‚Üí new devs just clone one repo.

‚ùå Cons
Repo can become huge as services grow.
Coupling risk ‚Üí devs may unintentionally break or change multiple services.
Slower builds/tests if not optimized.
Harder to enforce service independence (teams may ‚Äúpeek‚Äù into each other‚Äôs services).


Option 2: Multiple Repos (Polyrepo / Multi-repo)
Each microservice has its own repository.
‚úÖ Pros
True independence ‚Üí each service evolves, deploys, and scales independently.
Ownership clarity ‚Üí one team = one service = one repo.
Smaller repo size ‚Üí faster cloning, builds, and CI/CD.
Better alignment with autonomous team culture (common in microservices).

‚ùå Cons
Shared libraries become harder to manage (versioning, updates).
Cross-service changes require PRs in multiple repos.
Onboarding is harder (new devs need access to multiple repos).
More overhead for repo management & CI/CD pipelines.


HLD LLD 
-------
HLD[Output: System architecture diagrams, data flow, integration points.] - Bird's eye view of the system 
components, modules, APIs, databases, external integrations.
databases, message queues, caching systems, load balancers
scalability, availability, security, and performance concerns
Example (E-commerce System HLD)
Services: Auth Service, Product Service, Order Service, Payment Service.
Database choices: MySQL for transactions, Redis for caching.
Communication: REST APIs, Kafka for async events.
Deployment: Services run in Kubernetes, behind API Gateway & Load Balancer.

LLD - detailed floor plan with wiring & plumbing of that house.
It answers how each component will be implemented.
Detailed class diagrams, methods, database schemas, API contracts.
Focus on logic inside components.
Defines design patterns to be used (Factory, Observer, Singleton, etc.).
Deals with error handling, concurrency, and data validation.
Very close to actual code structure.
Example (E-commerce System LLD ‚Üí Order Service)
Classes: Order, Cart, OrderRepository, OrderController.
Methods: addItemToCart(), checkout(), calculateTotal().
DB Schema: orders table, order_items table with foreign keys.
Patterns: Use Repository pattern for DB access, Observer for sending notifications.
Output: Class diagrams, sequence diagrams, pseudo-code.

HLD = Big picture (modules, architecture, components).
LLD = Detailed implementation (classes, methods, schema).



Software Design Pattern Vs Agentic Design Pattern 
--------------------------------------------------
Software Design Pattern
-----------------------
Factory 
Observer 
Singleton 


Agentic Design Pattern 
----------------------


ACID - Database 
---------------
ACID is a set of properties in databases that ensures transactions are processed reliably and consistently.
1.Whenever we talk about transactions (like transferring money, placing an order, updating inventory), ACID guarantees that the database handles them safely.
A - Atomicity 
1. A ‚Äì Atomicity
A transaction is all-or-nothing.
If one part fails, the entire transaction rolls back.
‚úÖ Example: In a bank transfer from Account A ‚Üí Account B:
Debit A by $100
Credit B by $100
If credit fails, debit must also roll back.
C ‚Äì Consistency
A transaction must take the database from one valid state to another valid state, following all rules (constraints, triggers).
‚úÖ Example: If a column requires balance ‚â• 0, the database should reject a transaction that makes balance negative.
I ‚Äì Isolation
Transactions running at the same time should not interfere with each other.
Each transaction should behave as if it‚Äôs the only one executing.
‚úÖ Example: Two users buying the last item at the same time:
Only one purchase succeeds, the other rolls back.
D ‚Äì Durability
Once a transaction is committed, it is permanent, even if the system crashes.
‚úÖ Example: If you buy a product and receive a confirmation, the order will remain in the system even if the server restarts.

In System Design
Relational Databases (MySQL, PostgreSQL, Oracle, SQL Server) ‚Üí follow ACID strictly.
NoSQL Databases (MongoDB, Cassandra, DynamoDB) ‚Üí often relax some ACID properties to gain scalability & performance, instead focusing on BASE (Basically Available, Soft-state, Eventually consistent).

Imagine buying something online:
Atomicity ‚Üí Either payment succeeds + order placed, or nothing happens.
Consistency ‚Üí Your wallet balance, inventory, and order records remain valid.
Isolation ‚Üí Another user buying at the same time doesn‚Äôt mess up your purchase.
Durability ‚Üí Once confirmed, your order won‚Äôt vanish even if the site crashes.

BASE (used in distributed systems like NoSQL)
--------------------------------------------

Distributed Systems 
-------------------
A Distributed System is a collection of independent computers (nodes/servers) that appear to the user as a single system and work together to achieve a common goal.
Instead of running everything on one machine, work is split across multiple machines connected via a network.
Examples of Distributed Systems
Google Search ‚Üí billions of servers working together.
Netflix ‚Üí distributed streaming servers across the globe.
Amazon / Flipkart ‚Üí microservices + databases spread across multiple regions.
Apache Hadoop / Spark ‚Üí distributed data processing.

Key Characteristics
Multiple nodes (servers/computers).
Communication via network (not shared memory).
Transparency ‚Üí users shouldn‚Äôt care which machine handles their request.
Fault tolerance ‚Üí even if some nodes fail, the system continues.
Scalability ‚Üí can add more machines to handle growth.

Types of Distributed Systems
Client-Server Systems ‚Üí e.g., web apps (browser = client, backend = server).
Peer-to-Peer Systems ‚Üí e.g., BitTorrent, blockchain.
Clustered Systems ‚Üí e.g., Hadoop cluster, Kubernetes cluster.
Distributed Databases ‚Üí e.g., Cassandra, MongoDB, DynamoDB.

Advantages
Scalability ‚Üí handle more users by adding servers.
Fault tolerance ‚Üí some servers can fail without total system failure.
Performance ‚Üí tasks can run in parallel.
Geographical distribution ‚Üí servers closer to users (CDNs).

Network issues (latency, partitioning).
Consistency (ensuring all nodes have the same data).
Fault tolerance (handling crashes gracefully).
Coordination between distributed services.

This is where concepts like **CAP Theorem, ACID vs BASE, consensus algorithms (Paxos, Raft, Zookeeper) come into play.

Eg:
Imagine a food delivery system:
One kitchen (single server) ‚Üí handles all orders.
If too many orders come, it gets overloaded.
Solution ‚Üí Distributed kitchens (servers) across the city:
Each kitchen handles orders nearby.
If one kitchen fails, others still serve customers.
To the customer, it feels like one app, one system.


ACID vs BASE
------------

Oracle
------
Visual of Oracle Cloud Infrastructure
1.1. Oracle Cloud Infrastructure (OCI) - Oracle provides a comprehensive suite of cloud services that support various workloads‚Äîfrom legacy systems to modern cloud-native applications
Compute, Storage, Networking
Databases: Autonomous Database, MySQL, Oracle Database, NoSQL 
Analytics & Big Data, AI & Machine Learning, Data Science, Blockchain, IoT, Observability & Management 
Integration, Developer Tools, Intelligent Bots: API management, DevOps, low-code tools, blockchain platform, and more
OCI supports multiple deployment models - public cloud, hybrid deployments, dedicated regional offerings, distributed/hybrid clouds
across on-premises and data centers

2.Oracle Cloud Applications (SaaS)
1.Oracle offers a robust lineup of Software-as-a-Service (SaaS) applications for major business functions:
ERP (Enterprise Resource Planning): Financials, procurement, project management, compliance, supply chain, manufacturing, analytics
EPM (Enterprise Performance Management): Planning, profitability, financial consolidation, tax, narrative reporting, data management
SCM (Supply Chain Management): Inventory, logistics, manufacturing, order and lifecycle management
HCM (Human Capital Management): Recruiting, workforce modeling, talent and compensation, onboarding, payroll (Fusion Cloud HCM)
Customer Experience (CX) Tools: Sales, Marketing, Service, CPQ (Configure Price Quote)
These SaaS offerings are tightly integrated with Oracle‚Äôs cloud infrastructure, allowing for scalable, seamless enterprise operations

3. Enterprise Software & Middleware - Oracle‚Äôs on-premises and hybrid solutions include:
Enterprise Management: Oracle Enterprise Manager for unified monitoring (databases, middleware, applications, cloud)
Middleware: Fusion Middleware delivers tools for application servers, SOA, integration, BI, development, identity management, and more
Components include WebLogic, SOA Suite, ADF, JDeveloper, TopLink (ORM), ESB, Business Intelligence (OBIEE), Identity Management suite

4.Databases & Advanced Data Services
You can choose from:
Oracle Database (Enterprise, Standard, Express editions) ‚Äî the industry-leading RDBMS
NoSQL Database ‚Äî scalable key-value store for dynamic workloads, available as managed cloud service

Optional database features include multitenant architecture, Real Application Clusters, OLAP, spatial analytics, machine learning extensions, compression, and lifecycle management tools

5. Applications & Legacy (On-Premise) Solutions
Oracle continues to support a wide array of longstanding enterprise products:
ERP Suites: E-Business Suite, PeopleSoft, JD Edwards (EnterpriseOne & World), Fusion ERP
Planning & Performance Tools: Hyperion Planning, part of Oracle‚Äôs financial planning solutions

6.Development, Decision Automation, & Other Specialized Services
Oracle Intelligent Advisor (formerly Policy Automation) delivers business-rule modeling and decision automation‚Äîavailable as SaaS or on-premise, with integration APIs
Development Tools: Alongside middleware, Oracle provides tools for ORM, REST services, developer frameworks, and low-code application creation

What Can You Do with Oracle?
Run infrastructure (private, public, hybrid cloud)
Host enterprise-grade applications (financials, HR, supply chain)
Manage data with database and analytics platforms
Automate business processes and decisions
Develop custom applications with modern tools and low-code environments
Modernize existing legacy systems with integrated cloud strategies


Building High-Load and High-Resilience Systems [https://github.com/vitalii-honchar]
----------------------------------------------
Go, Java, Kotlin, Python, JavaScript
AWS, GCP, Kubernetes, Docker, Terraform, CI/CD
Postgres, CockroachDB, MongoDB, MySQL
AI Agents, ML Ops, LLMs

MicroServices
Monolith
Event-Driven
Domain-Driven Design 
Modular Monolith 

Software Scalability 
Performance
Security


AI Infrastructure, High-Load Systems, 
BackEnd Engineering 
LLM-Powered APIs and backend architecture 
https://vitaliihonchar.com/


Design Patterns Cheat Sheet 
---------------------------
Factory [Creational Design Patterns]
Provides an interface for creating objects in a superclass but allows subclasses to alter the type of objects 
that will be created. 
1.It helps in creating objects without exposing the object creation logic to the client code
eg: 
from abc import ABC, abstractmethod 

# Step 1: Define an interface (abstract class)
class Vehicle(ABC):
  @abstractmethod
  def drive(self):
    pass 
# Step 2: Concrete implementations
class Car(Vehicle):
    def drive(self):
        return "Driving a Car üöó"
class Bike(Vehicle):
    def drive(self):
        return "Riding a Bike üèçÔ∏è"
class Truck(Vehicle):
    def drive(self):
        return "Driving a Truck üöö"

# Step 3: Factory class
class VehicleFactory:
    @staticmethod
    def create_vehicle(vehicle_type: str) -> Vehicle:
        if vehicle_type == "car":
            return Car()
        elif vehicle_type == "bike":
            return Bike()
        elif vehicle_type == "truck":
            return Truck()
        else:
            raise ValueError(f"Unknown vehicle type: {vehicle_type}")

# Step 4: Client code
if __name__ == "__main__":
    factory = VehicleFactory()

# Client does not worry about "how" objects are created
    vehicles = ["car", "bike", "truck"]

    for v in vehicles:
        vehicle = factory.create_vehicle(v)
        print(vehicle.drive())
1.Encapsulation of object creation -> Client does not know class names or constructors.
2.Flexibility -> Adding a new type (say Bus) only requires updating the factory, not all client code.
3.Loose Coupling -> Client depends only on the Vehicle interface, not on concrete implementations.

Step 1: Product (Interface / Abstract Class)
from abc import ABC, abstractmethod

class Shape(ABC):   # <interface> Product
    @abstractmethod
    def draw(self) -> str:
        pass

Step 2: Concrete Products
class Circle(Shape):   # ConcreteProduct
    def draw(self) -> str:
        return "Drawing a Circle ‚≠ï"

class Square(Shape):   # ConcreteProduct
    def draw(self) -> str:
        return "Drawing a Square ‚óºÔ∏è"

Step 3: Creator (Abstract Factory Class)
class ShapeCreator(ABC):   # <abstract> Creator
    @abstractmethod
    def create_shape(self) -> Shape:
        pass

Step 4: Concrete Creators
class CircleCreator(ShapeCreator):   # ConcreteCreator
    def create_shape(self) -> Shape:
        return Circle()

class SquareCreator(ShapeCreator):   # ConcreteCreator
    def create_shape(self) -> Shape:
        return Square()

Step 5: Client Code
if __name__ == "__main__":
    # Client does not know HOW objects are created
    creators = [CircleCreator(), SquareCreator()]

    for creator in creators:
        shape = creator.create_shape()   # Factory method in action
        print(shape.draw())

<interface> Product ‚Üí Shape
ConcreteProduct ‚Üí Circle, Square
<abstract> Creator ‚Üí ShapeCreator
ConcreteCreator ‚Üí CircleCreator, SquareCreator
Client ‚Üí main function

--------------
Abstract Factory Pattern
Provides an interface for creating families of related or dependent objects without specifying their concrete classes.
1.The Factory Method (what we just discussed) creates one product at a time.
2.The Abstract Factory creates related products (a family) together.
3.Client code works only with interfaces/abstract types, never concrete classes.

Example in Python: GUI Toolkit (Windows / MacOS)
Imagine you want to build a GUI library that supports multiple operating systems (Windows, Mac).
Each OS has its own family of UI elements: buttons and checkboxes.
We want the client to be able to use them without worrying about which OS is running.

Step 1: Abstract Products
from abc import ABC, abstractmethod

# Abstract Product A
class Button(ABC):
    @abstractmethod
    def paint(self) -> str:
        pass

# Abstract Product B
class Checkbox(ABC):
    @abstractmethod
    def paint(self) -> str:
        pass

Step 2: Concrete Products
# Windows family
class WindowsButton(Button):
    def paint(self) -> str:
        return "Rendering a Windows Button ü™ü"

class WindowsCheckbox(Checkbox):
    def paint(self) -> str:
        return "Rendering a Windows Checkbox ‚òëÔ∏è"

# Mac family
class MacButton(Button):
    def paint(self) -> str:
        return "Rendering a Mac Button üçè"

class MacCheckbox(Checkbox):
    def paint(self) -> str:
        return "Rendering a Mac Checkbox ‚úÖ"

Step 3: Abstract Factory
class GUIFactory(ABC):   # <interface> AbstractFactory
    @abstractmethod
    def create_button(self) -> Button:
        pass

    @abstractmethod
    def create_checkbox(self) -> Checkbox:
        pass

Step 4: Concrete Factories
class WindowsFactory(GUIFactory):
    def create_button(self) -> Button:
        return WindowsButton()

    def create_checkbox(self) -> Checkbox:
        return WindowsCheckbox()


class MacFactory(GUIFactory):
    def create_button(self) -> Button:
        return MacButton()

    def create_checkbox(self) -> Checkbox:
        return MacCheckbox()

Step 5: Client Code
def client_code(factory: GUIFactory):
    button = factory.create_button()
    checkbox = factory.create_checkbox()
    print(button.paint())
    print(checkbox.paint())


if __name__ == "__main__":
    print("Using Windows Factory:")
    client_code(WindowsFactory())

    print("\nUsing Mac Factory:")
    client_code(MacFactory())


------------------
Builder 
-------------------
Constructs a complex object step by step, allowing for greater control over the construction process and enabling different representations of the object.
When creating complex objects (with many parts), instead of a huge constructor with many parameters, we use a Builder.
The Builder pattern separates the construction of an object from its representation, so the same construction process can create different kinds of objects.

Example in Python: Building a Computer
We want to construct a Computer object with multiple parts: CPU, GPU, RAM, and Storage.
Instead of calling a constructor with many arguments, we use a Builder to assemble it step by step.


Step 1: Product (the complex object)
class Computer:
    def __init__(self):
        self.cpu = None
        self.gpu = None
        self.ram = None
        self.storage = None

    def __str__(self):
        return f"Computer with CPU={self.cpu}, GPU={self.gpu}, RAM={self.ram}, Storage={self.storage}"

Step 2: Builder Interface
from abc import ABC, abstractmethod

class ComputerBuilder(ABC):
    @abstractmethod
    def build_cpu(self): pass

    @abstractmethod
    def build_gpu(self): pass

    @abstractmethod
    def build_ram(self): pass

    @abstractmethod
    def build_storage(self): pass

    @abstractmethod
    def get_result(self) -> Computer: pass

Step 3: Concrete Builders
class GamingComputerBuilder(ComputerBuilder):
    def __init__(self):
        self.computer = Computer()

    def build_cpu(self):
        self.computer.cpu = "Intel i9"

    def build_gpu(self):
        self.computer.gpu = "NVIDIA RTX 4090"

    def build_ram(self):
        self.computer.ram = "32GB DDR5"

    def build_storage(self):
        self.computer.storage = "2TB SSD"

    def get_result(self) -> Computer:
        return self.computer


class OfficeComputerBuilder(ComputerBuilder):
    def __init__(self):
        self.computer = Computer()

    def build_cpu(self):
        self.computer.cpu = "Intel i5"

    def build_gpu(self):
        self.computer.gpu = "Integrated Graphics"

    def build_ram(self):
        self.computer.ram = "16GB DDR4"

    def build_storage(self):
        self.computer.storage = "512GB SSD"

    def get_result(self) -> Computer:
        return self.computer


Step 4: Director (orchestrates construction)
class Director:
    def __init__(self, builder: ComputerBuilder):
        self.builder = builder

    def construct_computer(self):
        self.builder.build_cpu()
        self.builder.build_gpu()
        self.builder.build_ram()
        self.builder.build_storage()
        return self.builder.get_result()

Step 5: Client Code
if __name__ == "__main__":
    # Build a gaming computer
    gaming_builder = GamingComputerBuilder()
    director = Director(gaming_builder)
    gaming_pc = director.construct_computer()
    print(gaming_pc)

    # Build an office computer
    office_builder = OfficeComputerBuilder()
    director = Director(office_builder)
    office_pc = director.construct_computer()
    print(office_pc)

Builder is useful when:
You need to create objects with many optional/mandatory fields.
You want different representations of the same object (gaming vs office computer).


--------------------------
Prototype Design Pattern
----------------------
Prototype Design Pattern
Specify the kinds of objects to create using a prototypical instance, and create new objects by cloning this prototype.
Key Idea
Instead of creating objects from scratch (with new or constructors), you make a copy of an existing object (the prototype).
Useful when:
Object creation is expensive (time-consuming or resource-heavy).
You want to keep the initial state of an object and reuse it.
You need copies of objects with slight modifications.

Example in Python: Cloning Shapes
We want to create Circle and Rectangle objects. Instead of instantiating from scratch every time, we clone prototypes.

Step 1: Prototype Interface
from abc import ABC, abstractmethod
import copy

class Prototype(ABC):
    @abstractmethod
    def clone(self):
        pass

Step 2: Concrete Prototypes
class Circle(Prototype):
    def __init__(self, radius, color):
        self.radius = radius
        self.color = color

    def clone(self):
        return copy.deepcopy(self)

    def __str__(self):
        return f"Circle(radius={self.radius}, color={self.color})"


class Rectangle(Prototype):
    def __init__(self, width, height, color):
        self.width = width
        self.height = height
        self.color = color

    def clone(self):
        return copy.deepcopy(self)

    def __str__(self):
        return f"Rectangle(width={self.width}, height={self.height}, color={self.color})"

Step 3: Client Code
if __name__ == "__main__":
    # Create prototypes
    circle1 = Circle(5, "red")
    rectangle1 = Rectangle(10, 20, "blue")

    # Clone them
    circle2 = circle1.clone()
    rectangle2 = rectangle1.clone()

    # Modify the clones
    circle2.color = "green"
    rectangle2.width = 15

    print(circle1)   # Original
    print(circle2)   # Cloned + modified
    print(rectangle1)
    print(rectangle2)


Prototype is particularly powerful when you need many copies of a configured object, e.g., game objects, GUI elements, or database records.

-------------
Singleton 
-------------
Ensure a class has only one instance, and provide a global point of access to it.

Key Idea
Sometimes, you want to restrict a class so that only one object can exist.
Common in cases like:
Configuration managers (only one config should exist across app).
Logging systems (a single logger instance).
Database connections (only one connection pool).

Example in Python: Logger Singleton
class Logger:
    _instance = None   # Class-level private variable

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            print("Creating new Logger instance...")
            cls._instance = super().__new__(cls)
        return cls._instance

    def log(self, message: str):
        print(f"[LOG]: {message}")
Step 2: Client Code
if __name__ == "__main__":
    logger1 = Logger()
    logger2 = Logger()

    logger1.log("First message")
    logger2.log("Second message")

    print("logger1 is logger2:", logger1 is logger2)

Mapping back to the diagram
Singleton class ‚Üí Logger
Static instance ‚Üí _instance variable
Global access point ‚Üí __new__ ensures only one object is created

In Python, Singleton is often implemented using __new__, metaclasses, or decorators.
It ensures only one instance, but remember: overusing Singleton can make testing harder if abused.

------------------
Creational Patterns - Factory - Abstract Factory  - Builder - Prototype - Singleton 
-------------------------
Structural Design Patterns   - Adapter - Bridge - Composite - Decorator - Facade - Flyweight - Proxy 
--------------------------
Behavioral Design Patterns - chain of Responsibility - Command - Interpreter - Iterator - Mediator - Memento
--------------------------
Adapter - Adapter is super useful when integrating old code (legacy) with new systems without modifying either.









Doubt: What is Interface & Abstraction
How Task can run in parallel in distributed system 
Client-Server Systems ‚Üí e.g., web apps (browser = client, backend = server). ? how it will work in the Distributed System 
Microservices - will run in the Kubernetes and managed - How it will work in Distributed System.
How to Handle the More Number of Users 
How to Handel More Number of Users 
















                       







