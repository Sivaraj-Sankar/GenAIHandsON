from collections import Counter 
1. Counter(numbers).most_common(1)
2. counter.most_common()[-1]
3. counter.values()
4. counter.items()

1.from collections import OrderedDict
od = OrderedDict()
od['apple'] = 3
od['banana'] = 5
od['orange'] = 2
2. Comparing two Dict 
od1 = OrderedDict(a=1, b=2)
od2 = OrderedDict(b=2, a=1)
print(od1 == od2)  # False, order is different
3. Inputing the Ordered Dict -> c = OrderedDict([("S","D"),("D","D")])
d = OrderedDict(a=1,b=1,c=2)
b = OrderedDict({})
b["siva"] = "raj"

defaultdict(default_factory, mapping_or_iterable=None)
1.from collections import defaultdict
a = defaultdict(list)
print(l['Sivaraj'])
person_count = defaultdict(int)  # default value = 0
person_count['Alice'] += 1
person_count['Bob'] += 1

from collections import defaultdict
person = {'Alice': 25, 'Bob': 30}
# default value is "unknown" for missing keys
person_dd = defaultdict(lambda: "unknown", person)
print(person_dd['Alice'])   # 25  (existing key)
print(person_dd['Charlie']) # unknown  (missing key)




1.a = float('-inf')

print(a.isalpha())
print(a.isdigit())
print(a.isalnum())
print(a.isdecimal())
print(a.isspace())

1.# True if there is any non-alphanumeric character
has_special = any(not ch.isalnum() for ch in s)  --> any(iterable)

str.count(sub[, start[, end]]) → Count occurrences of substring.
str.find(sub[, start[, end]]) → Index of first occurrence, -1 if not found.
str.rfind(sub[, start[, end]]) → Index of last occurrence, -1 if not found.
str.index(sub[, start[, end]]) → Like find(), but raises ValueError if not found.
str.rindex(sub[, start[, end]]) → Like rfind(), but raises ValueError if not found.
str.startswith(prefix[, start[, end]]) → Checks if string starts with prefix.
str.endswith(suffix[, start[, end]]) → Checks if string ends with suffix.
str.partition(sep) → Splits into tuple (before, sep, after) at first occurrence.
str.rpartition(sep) → Splits at last occurrence.
str.split(sep=None, maxsplit=-1) → Splits string into list.
str.rsplit(sep=None, maxsplit=-1) → Splits string from right.
str.splitlines(keepends=False) → Splits string at line breaks.
str.replace(old, new[, count]) → Replaces occurrences of a substring.
Trimming/Stripping
str.strip([chars]) → Removes leading/trailing whitespace or characters.
str.lstrip([chars]) → Removes leading characters.
str.rstrip([chars]) → Removes trailing characters.
str.removeprefix(prefix) → Removes prefix if present (Python 3.9+).
str.removesuffix(suffix) → Removes suffix if present (Python 3.9+).
Joining/Formatting
str.join(iterable) → Joins elements of iterable with the string as separator.
str.format(*args, **kwargs) → Formats string with placeholders.
str.format_map(mapping) → Like format(), but uses a mapping (dict).
str.maketrans(x, y=None, z='') → Returns translation table for translate().
str.translate(table) → Translates string using a translation table.
Padding/Aligning
str.center(width[, fillchar]) → Centers string.
str.ljust(width[, fillchar]) → Left-aligns string.
str.rjust(width[, fillchar]) → Right-aligns string.
str.zfill(width) → Pads string with zeros on the left.
Encoding/Decoding
str.encode(encoding='utf-8', errors='strict') → Encodes string to bytes.
str.decode() → Only on bytes, not string.
Other Useful Methods
str.isnumeric() → Checks if all chars are numeric.
str.isprintable() → Checks if all chars are printable.
str.expandtabs(tabsize=8) → Replaces tabs \t with spaces.



1. Decorator 
def dec(func):
    def wrapper():
        print("Before the main function")
        func()
    return wrapper
    
    
@dec
def say_hello():
    print("This is the main function")
    
say_hello()

# Selection Sorting  ---> Playing with Index
2 for loop is for looping
a = [1,3,54,3,5]
n = len(a)
for i in range(n):
    min_index = i 
    for j in range(i+1,n):
        if a[min_index] > a[j]:
            min_index = j 
    a[min_index],a[i] = a[i],a[min_index]
print(a)

# Insertion Sorting  ---> Playing with Key 
2 for loop is for updating the min_index
arr= [1,3,2,4,3,5,5]
n = len(arr)
for i in range(1,n):
    key = arr[i]
    j = i - 1 
    while j > 0 and arr[j] > key:
        arr[j+1] = arr[j]
        j-=1 
    arr[j+1] = key 
print(arr)

# Quick Sorting -> Playing with Recursion 
a = [1,3,5,3,5,2,4,3]

def Quick(a):
    if len(a) <= 1:
        return a 
    pivot = a[len(a)//2]
    left = [i for i in a if i<pivot]
    middle = [i for i in a if i==pivot]
    right = [i for i in a if i>pivot]
    return Quick(left) + middle + Quick(right)

d = Quick(a)
print(d)

#Merge Sorting 

def Merge(arr):
    if len(arr) <=1:
        return arr
    middle = len(arr)//2 
    left   = Merge(arr[:middle])
    right  = Merge(arr[middle:])

    retrun Merge_sort(left,right) 
def Merge_sort(left,right):
    sorted_list = [] 
    i = j = 0 
    While i < len(left) and j < len(right):
        if left[i] <  right[j]:
            sorted_list.append(left[i])
            i+=1  
        else:
            sorted_list.append(right[j])
            j+=1 
    sorted_list.extend(left[i:])
    sorted_list.exten(right[j:])

Best Time to Buy and Sell Stock   ---> Set the min_price by looping, that is buy 
prices = [13,2,54,2,5,3]
max_profit = 0 
min_price = float('inf')

for i in range(len(prices)):
    if prices[i] < min_price:
        min_price = prices[i] #Buy
    else: 
        max_profit = max(max_profit, prices[i] - min_price)
print(max_profit)


Maximum Subarray --->       Finding the Maximum Subarray --> continuous Sub Array 
Find the contiguous subarray (containing at least one number) which has the largest sum, and return its sum
This is a classic Dynamic Programming problem, known as Kadane's Algorithm.
You track the maximum sum ending at each index, and the global maximum so far.
# Finding the Maximum SubArray 

a = [1,3,-4,3,5,3,5]
max_global = max_current = a[0]
for i in range(1,len(a)):
    max_current = max(a[i],max_current + a[i])
    max_global = max(max_global, max_current)
print(max_global)
print(sum(a))


Binary Search ---> 
# Binary Search  --> left, right 


def search(nums,target):
    left, right = 0,len(nums)-1
    
    while left <= right:
        mid = (left+right)//2
        if nums[mid] == target:
            return num[mid]
        elif nums[left] < target:
            left = mid + 1 
        else
            right = mid -1 
    return -1

Top K Frequent Elements
number of top of K frequent elements 




Buy --> finding the min_price 
SubArray  -> Kadane's Algo -> simple, current, global 
binary_search -> simple 


    
    
    




To Revise 
popitem
iterator 
generator 


1.RAG - Different Chunking, VB, Retrieval, Caching, Fallback, Prompting, Testing, LangGraph 
2.Previous Project Compliance Ready Project - Obscure, Data Privacy and Governance , DDD Design , FastAPI, Azure Service to Deploy, Onion Layer Approach of System, Adapter , Controller, 
3.General GenAI Topic - Different Parameter, Transformer Usage and Mathematical, Agentic AI
4.General Machine Learning - Trade-Off, Bias, Variance, Gradient Descent, Not Convergence Reason, Neural Network
5.Software Engineering Principles - SOLID,KISS, Design Pattern, LLD, HLD[Architecting]

Where I will Stuck 
1. In Services I have Used - Memory for Agent[How I Stored the Response]
2. In Coding related to framework Specific 
3. In FastAPI & ReactJS - Related to web technology - Authentication, Authorization, Fallback, Callback, Caching, Load Balancing, DataBase Optimizing(Indexing)
4. Actual Deployment of my Project 
5. Responsible AI Approach 

Services I used 
1. Postgresql in the Azure - used to store the Converstation History [Window Buffer, Semanitc, Summarizing, Long-Term[Need Vector Store and Indexing to Search], Short-Term]
2. Redis for Caching the LLM Response - in the Azure 
3. MongoDB Vector Store 
4. 










