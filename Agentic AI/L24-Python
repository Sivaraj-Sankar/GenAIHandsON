MRO - Method Resolution Object
print(SubClass.__mro__)
print(SubClass.mro())
class BaseClass:
    def method(self):
        print("Sivaraj")
        
class BaseClass1:
    def method(self):
        print("Sivaraj1")
        
class SubClass(BaseClass,BaseClass1):
    pass
    
subclass = SubClass()
print(type(subclass))
subclass.method()
print(type(subclass))
--------------
Factory pattern: returning Base instead of Sub
                  ---------------------------
<class '__main__.Base'>
This technique is often used in:
Singletons
Wrappers
Proxy objects
Custom class factories

--------------------------
Case 1: Overriding __new__ Method   [__new__ is responsible for creating the instance (before __init__ is called).]
If Sub explicitly returns a BaseClass object from its __new__ method,
class Base:
    def method(self):
        print("Sivaraj")

class Sub(Base):
    def __new__(cls):
        print("Creating Sub instance...")
        # Instead of creating Sub, return Base instance
        return Base()
        
s = Sub()
print(type(s))

---------------------------------------------------------------------------------
Case 3: Using __init_subclass__ or Metaclasses (Advanced)
In advanced frameworks (like Django ORM, SQLAlchemy, Pydantic, etc.),
metaclasses or __init_subclass__ can dynamically replace or modify subclasses during creation.
you might actually see Base or even a proxy class — because the metaclass changed what Sub() produces.
Metaclass or framework manipulation
Object creation overridden dynamically

----------------------------------------------
MetaClasses
In Python, everything is an object — even classes themselves are objects.
The “class” of a class is called a metaclass.

A metaclass defines how a class behaves, just like a class defines how its instances behave.



----------------------
Instance , Static, Class 
Instance Method
The first argument is always self, which refers to the current instance.
Can access instance variables and class variables.
Called using the Objects


class BaseClass():
    
    a = "10"
    
    @staticmethod
    def method1():
        return "sivaraj"
        
    @classmethod
    def method2(cls):
        print(cls)
        return "Sivaraj1" + cls.a
        
    def method(self):
        print(self)
        return "Sivaraj" + self.a


B = BaseClass()
print(B.method())
#print(BaseClass.method("self"))
print(BaseClass.method1())
print(B.method1())
print(B.method2())
#print(BaseClass.method2())
-----------------------------------------
Public(everywhere) Protected{class & subclass) Private{within class}

class MyClass:
    def __init__(self):
        self.public_var = "Public"
        self._protected_var = "Protected"
        self.__private_var = "Private"

    def display(self):
        print("Inside class:")
        print(self.public_var)
        print(self._protected_var)
        print(self.__private_var)



C = MyClass()
C.display()
print(C.public_var)
print(C._protected_var)
print(C.__private_var)

---------------------
Docker File 

# 1️⃣ Base image
FROM python:3.10-slim

# 2️⃣ Set working directory inside container
WORKDIR /app

# 3️⃣ Copy project files into container
COPY . .

# 4️⃣ Install dependencies
RUN pip install -r requirements.txt

# 5️⃣ Command to run your app
CMD ["python", "app.py"]

docker build -t my-python-app .
docker run my-python-app



Instruction	Description
FROM	Base image (e.g., python:3.10, ubuntu:20.04)
WORKDIR	Set working directory inside the container
COPY	Copy files from host to container
RUN	Run commands while building the image (e.g., install dependencies)
CMD	Default command that runs when container starts
EXPOSE	Inform Docker which port the app listens on
ENV	Set environment variables
ENTRYPOINT	Similar to CMD, but fixed entry command
ARG	Build-time variables


FROM python:3.10

WORKDIR /app
COPY . .

RUN pip install fastapi uvicorn

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
docker build -t fastapi-app .
docker run -p 8000:8000 fastapi-app
host_port	The port number on your local machine (laptop/server)
container_port	The port number inside the container where the app is running


Docker Compose 
-------------------
environment, ports, volumes, networks, dependencies —
in one single file.
docker-compose up


version: "3.9"

services:
  web:
    build: .                                            -----> Build Image using the Docker file in the Current Directory 
    container_name: fastapi-app
    ports:
      - "8000:8000"
    depends_on:                                        -------> Ensures FastAPI starts after the database
      - db
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/mydb

  db:
    image: postgres:15
    container_name: fastapi-db
    restart: always
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=mydb
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:



docker-compose up	Start all services defined in the file
docker-compose up -d	Run in detached (background) mode
docker-compose down	Stop and remove containers, networks, volumes
docker-compose build	Rebuild all images
docker-compose logs	View combined logs from all services


__slots__
---------------------------------------------
Normally, every Python object (like an instance of a class) stores its attributes in a dictionary (__dict__)
That makes it flexible — you can add or remove attributes dynamically at runtime.
But this flexibility uses more memory and slows down attribute access.


class Person:
    __slots__ = ['name', 'age']   # only these two attributes allowed

    def __init__(self, name, age):
        self.name = name
        self.age = age

p = Person("Sivaraj", 25)
print(p.name)  # Sivaraj





Generator 
Iterator 
  def my_iterator(data):
    for item in data:
        yield item 
        
for i in my_iterator([10,20,30]):
    print(i)


a = [10,20,30]

c = iter(a)
print(next(c))
print(next(c))


def my_generator():
    yield 1
    yield 2
    yield 3

gen = my_generator()

print(next(gen))  # 1
print(next(gen))  # 2
print(next(gen))  # 3
# next(gen) → StopIteration





Deep Agents Working Prototype 
LangGraph State Concepts - different State Concepts 
sotring and key function --> how to use - Done
Data Base Connection , PostgreSQL, MongoDB Connection - Done
Content Safety Concepts - https://learn.microsoft.com/en-us/azure/ai-foundry/concepts/content-filtering?utm_source=chatgpt.com
                        - https://learn.microsoft.com/en-us/azure/ai-foundry/concepts/content-filtering?utm_source=chatgpt.com
RAI - API's - Responsible AI 
Guardrails 




from collections import Counter 
1. Counter(numbers).most_common(1)
2. counter.most_common()[-1]
3. counter.values()
4. counter.items()

1.from collections import OrderedDict
od = OrderedDict()
od['apple'] = 3
od['banana'] = 5
od['orange'] = 2
2. Comparing two Dict 
od1 = OrderedDict(a=1, b=2)
od2 = OrderedDict(b=2, a=1)
print(od1 == od2)  # False, order is different
3. Inputing the Ordered Dict -> c = OrderedDict([("S","D"),("D","D")])
d = OrderedDict(a=1,b=1,c=2)
b = OrderedDict({})
b["siva"] = "raj"

defaultdict(default_factory, mapping_or_iterable=None)
1.from collections import defaultdict
a = defaultdict(list)
print(l['Sivaraj'])
person_count = defaultdict(int)  # default value = 0
person_count['Alice'] += 1
person_count['Bob'] += 1

from collections import defaultdict
person = {'Alice': 25, 'Bob': 30}
# default value is "unknown" for missing keys
person_dd = defaultdict(lambda: "unknown", person)
print(person_dd['Alice'])   # 25  (existing key)
print(person_dd['Charlie']) # unknown  (missing key)




1.a = float('-inf')

print(a.isalpha())
print(a.isdigit())
print(a.isalnum())
print(a.isdecimal())
print(a.isspace())

1.# True if there is any non-alphanumeric character
has_special = any(not ch.isalnum() for ch in s)  --> any(iterable)

str.count(sub[, start[, end]]) → Count occurrences of substring.
str.find(sub[, start[, end]]) → Index of first occurrence, -1 if not found.
str.rfind(sub[, start[, end]]) → Index of last occurrence, -1 if not found.
str.index(sub[, start[, end]]) → Like find(), but raises ValueError if not found.
str.rindex(sub[, start[, end]]) → Like rfind(), but raises ValueError if not found.
str.startswith(prefix[, start[, end]]) → Checks if string starts with prefix.
str.endswith(suffix[, start[, end]]) → Checks if string ends with suffix.
str.partition(sep) → Splits into tuple (before, sep, after) at first occurrence.
str.rpartition(sep) → Splits at last occurrence.
str.split(sep=None, maxsplit=-1) → Splits string into list.
str.rsplit(sep=None, maxsplit=-1) → Splits string from right.
str.splitlines(keepends=False) → Splits string at line breaks.
str.replace(old, new[, count]) → Replaces occurrences of a substring.
Trimming/Stripping
str.strip([chars]) → Removes leading/trailing whitespace or characters.
str.lstrip([chars]) → Removes leading characters.
str.rstrip([chars]) → Removes trailing characters.
str.removeprefix(prefix) → Removes prefix if present (Python 3.9+).
str.removesuffix(suffix) → Removes suffix if present (Python 3.9+).
Joining/Formatting
str.join(iterable) → Joins elements of iterable with the string as separator.
str.format(*args, **kwargs) → Formats string with placeholders.
str.format_map(mapping) → Like format(), but uses a mapping (dict).
str.maketrans(x, y=None, z='') → Returns translation table for translate().
str.translate(table) → Translates string using a translation table.
Padding/Aligning
str.center(width[, fillchar]) → Centers string.
str.ljust(width[, fillchar]) → Left-aligns string.
str.rjust(width[, fillchar]) → Right-aligns string.
str.zfill(width) → Pads string with zeros on the left.
Encoding/Decoding
str.encode(encoding='utf-8', errors='strict') → Encodes string to bytes.
str.decode() → Only on bytes, not string.
Other Useful Methods
str.isnumeric() → Checks if all chars are numeric.
str.isprintable() → Checks if all chars are printable.
str.expandtabs(tabsize=8) → Replaces tabs \t with spaces.


complement sum 
a = [2,7,6,4]
target = 9 
num_maps = {}
for i,num in enumerate(a):
    complement = target - num 
    if complement in num_maps:
        print ([num_maps[complement],i])
        break
    num_maps[num] = i 

#Identifying the Duplicates 
a = [1,3,2,4,2]
seen = set()
for i in a:
    if i in seen:
        print("True") 
        break
    seen.add(i) 


#Maximum Common Subarray 
#Intersection of Two Arrays 
a = [1,2,4,235]
b = [2,4]   

for i in range(0,len(b)):
    for j in range(0,len(a)):
        #print(a[i:j+1])
        if a[i:j] == b:
            print(True)
        #if a[i:j] in b:
            max_results = a[i:j]
print(max_results)


#Intersection 
from collections import Counter


a = [1,3,43,5,3,3]
b = [3,4,5,3]

def Intersection(nums1,nums2):
    counts = Counter(nums2)
    results = []
    for i in nums1:
        if counts[i] > 0:
            results.append(i)
            counts[i]-=1
    return results
c = Intersection(a,b)
print(c)



1. Decorator 
def dec(func):
    def wrapper():
        print("Before the main function")
        func()
    return wrapper
    
    
@dec
def say_hello():
    print("This is the main function")
    
say_hello()

# Selection Sorting  ---> Playing with Index
2 for loop is for looping
a = [1,3,54,3,5]
n = len(a)
for i in range(n):
    min_index = i 
    for j in range(i+1,n):
        if a[min_index] > a[j]:
            min_index = j 
    a[min_index],a[i] = a[i],a[min_index]
print(a)

# Insertion Sorting  ---> Playing with Key 
2 for loop is for updating the min_index
arr= [1,3,2,4,3,5,5]
n = len(arr)
for i in range(1,n):
    key = arr[i]
    j = i - 1 
    while j > 0 and arr[j] > key:
        arr[j+1] = arr[j]
        j-=1 
    arr[j+1] = key 
print(arr)

# Quick Sorting -> Playing with Recursion 
a = [1,3,5,3,5,2,4,3]

def Quick(a):
    if len(a) <= 1:
        return a 
    pivot = a[len(a)//2]
    left = [i for i in a if i<pivot]
    middle = [i for i in a if i==pivot]
    right = [i for i in a if i>pivot]
    return Quick(left) + middle + Quick(right)

d = Quick(a)
print(d)

#Merge Sorting 

def Merge(arr):
    if len(arr) <=1:
        return arr
    middle = len(arr)//2 
    left   = Merge(arr[:middle])
    right  = Merge(arr[middle:])

    retrun Merge_sort(left,right) 
def Merge_sort(left,right):
    sorted_list = [] 
    i = j = 0 
    While i < len(left) and j < len(right):
        if left[i] <  right[j]:
            sorted_list.append(left[i])
            i+=1  
        else:
            sorted_list.append(right[j])
            j+=1 
    sorted_list.extend(left[i:])
    sorted_list.exten(right[j:])

Best Time to Buy and Sell Stock   ---> Set the min_price by looping, that is buy 
prices = [13,2,54,2,5,3]
max_profit = 0 
min_price = float('inf')

for i in range(len(prices)):
    if prices[i] < min_price:
        min_price = prices[i] #Buy
    else: 
        max_profit = max(max_profit, prices[i] - min_price)
print(max_profit)


Maximum Subarray --->       Finding the Maximum Subarray --> continuous Sub Array 
Find the contiguous subarray (containing at least one number) which has the largest sum, and return its sum
This is a classic Dynamic Programming problem, known as Kadane's Algorithm.
You track the maximum sum ending at each index, and the global maximum so far.
# Finding the Maximum SubArray 

a = [1,3,-4,3,5,3,5]
max_global = max_current = a[0]
for i in range(1,len(a)):
    max_current = max(a[i],max_current + a[i])
    max_global = max(max_global, max_current)
print(max_global)
print(sum(a))


Binary Search ---> 
# Binary Search  --> left, right 


def search(nums,target):
    left, right = 0,len(nums)-1
    
    while left <= right:
        mid = (left+right)//2
        if nums[mid] == target:
            return num[mid]
        elif nums[left] < target:
            left = mid + 1 
        else
            right = mid -1 
    return -1

Top K Frequent Elements
number of top of K frequent elements 
from collections import defaultdict, Counter

def topKFrequent(nums, k):
    freq_map = Counter(nums)
    bucket = [[] for _ in range(len(nums) + 1)]

    for num, freq in freq_map.items():
        bucket[freq].append(num)

    result = []
    for freq in range(len(bucket) - 1, 0, -1):
        for num in bucket[freq]:
            result.append(num)
            if len(result) == k:
                return result


Backtracking (DFS Recursion)
Subsets
❓ Problem Statement:
Given an integer array nums of unique elements, return all possible subsets (the power set).
The solution must not contain duplicate subsets, and you can return the answer in any order.
We'll build subsets by recursively adding or skipping each element.

Recursively adding or skipping the element
def subsets(nums):
    res = []

    def backtrack(start, path):
        res.append(path[:])  # Add a copy of the current subset
        for i in range(start, len(nums)):
            path.append(nums[i])            # Choose
            backtrack(i + 1, path)          # Explore
            path.pop()                      # Un-choose (backtrack)

    backtrack(0, [])
    return res

def subsets(nums):
    res = [[]]
    for num in nums:
        res = res + [item + [num] for item in res]
    return res

Longest Common_SubString - 

def longest_common_substring(s1, s2):
    s1, s2 = s1.lower(), s2.lower()  # case-insensitive
    longest = ""
    n = len(s1)
    if len(s1) < len(s2):
        n = len(s2)
        s1,s2 = s2,s1
    for i in range(n):
        for j in range(i + 1, n + 1):
            sub = s1[i:j]
            if sub in s2 and len(sub) > len(longest):
                longest = sub
    return longest, len(longest)
    
a = longest_common_substring("varat","Sivaraj")
print(a)









Buy --> finding the min_price 
SubArray  -> Kadane's Algo -> simple, current, global 
binary_search -> simple 


    
    
    




To Revise 
popitem
iterator 
generator 


1.RAG - Different Chunking, VB, Retrieval, Caching, Fallback, Prompting, Testing, LangGraph 
2.Previous Project Compliance Ready Project - Obscure, Data Privacy and Governance , DDD Design , FastAPI, Azure Service to Deploy, Onion Layer Approach of System, Adapter , Controller, 
3.General GenAI Topic - Different Parameter, Transformer Usage and Mathematical, Agentic AI
4.General Machine Learning - Trade-Off, Bias, Variance, Gradient Descent, Not Convergence Reason, Neural Network
5.Software Engineering Principles - SOLID,KISS, Design Pattern, LLD, HLD[Architecting]

Where I will Stuck 
1. In Services I have Used - Memory for Agent[How I Stored the Response]
2. In Coding related to framework Specific 
3. In FastAPI & ReactJS - Related to web technology - Authentication, Authorization, Fallback, Callback, Caching, Load Balancing, DataBase Optimizing(Indexing)
4. Actual Deployment of my Project 
5. Responsible AI Approach 

Services I used 
1. Postgresql in the Azure - used to store the Converstation History [Window Buffer, Semanitc, Summarizing, Long-Term[Need Vector Store and Indexing to Search], Short-Term]
2. Redis for Caching the LLM Response - in the Azure 
3. MongoDB Vector Store 
4. 










