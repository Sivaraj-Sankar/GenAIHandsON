MRO - Method Resolution Object
print(SubClass.__mro__)
print(SubClass.mro())
class BaseClass:
    def method(self):
        print("Sivaraj")
        
class BaseClass1:
    def method(self):
        print("Sivaraj1")
        
class SubClass(BaseClass,BaseClass1):
    pass
    
subclass = SubClass()
print(type(subclass))
subclass.method()
print(type(subclass))
--------------
Factory pattern: returning Base instead of Sub
                  ---------------------------
<class '__main__.Base'>
This technique is often used in:
Singletons
Wrappers
Proxy objects
Custom class factories

--------------------------
Case 1: Overriding __new__ Method   [__new__ is responsible for creating the instance (before __init__ is called).]
If Sub explicitly returns a BaseClass object from its __new__ method,
class Base:
    def method(self):
        print("Sivaraj")

class Sub(Base):
    def __new__(cls):
        print("Creating Sub instance...")
        # Instead of creating Sub, return Base instance
        return Base()
        
s = Sub()
print(type(s))

---------------------------------------------------------------------------------
Case 3: Using __init_subclass__ or Metaclasses (Advanced)
In advanced frameworks (like Django ORM, SQLAlchemy, Pydantic, etc.),
metaclasses or __init_subclass__ can dynamically replace or modify subclasses during creation.
you might actually see Base or even a proxy class — because the metaclass changed what Sub() produces.
Metaclass or framework manipulation
Object creation overridden dynamically

----------------------------------------------
MetaClasses
In Python, everything is an object — even classes themselves are objects.
The “class” of a class is called a metaclass.

A metaclass defines how a class behaves, just like a class defines how its instances behave.



----------------------
Instance , Static, Class 
Instance Method
The first argument is always self, which refers to the current instance.
Can access instance variables and class variables.
Called using the Objects


class BaseClass():
    
    a = "10"
    
    @staticmethod
    def method1():
        return "sivaraj"
        
    @classmethod
    def method2(cls):
        print(cls)
        return "Sivaraj1" + cls.a
        
    def method(self):
        print(self)
        return "Sivaraj" + self.a


B = BaseClass()
print(B.method())
#print(BaseClass.method("self"))
print(BaseClass.method1())
print(B.method1())
print(B.method2())
#print(BaseClass.method2())
-----------------------------------------
Public(everywhere) Protected{class & subclass) Private{within class}

class MyClass:
    def __init__(self):
        self.public_var = "Public"
        self._protected_var = "Protected"
        self.__private_var = "Private"

    def display(self):
        print("Inside class:")
        print(self.public_var)
        print(self._protected_var)
        print(self.__private_var)



C = MyClass()
C.display()
print(C.public_var)
print(C._protected_var)
print(C.__private_var)

---------------------
Docker File 

# 1️⃣ Base image
FROM python:3.10-slim

# 2️⃣ Set working directory inside container
WORKDIR /app

# 3️⃣ Copy project files into container
COPY . .

# 4️⃣ Install dependencies
RUN pip install -r requirements.txt

# 5️⃣ Command to run your app
CMD ["python", "app.py"]

docker build -t my-python-app .
docker run my-python-app



Instruction	Description
FROM	Base image (e.g., python:3.10, ubuntu:20.04)
WORKDIR	Set working directory inside the container
COPY	Copy files from host to container
RUN	Run commands while building the image (e.g., install dependencies)
CMD	Default command that runs when container starts
EXPOSE	Inform Docker which port the app listens on
ENV	Set environment variables
ENTRYPOINT	Similar to CMD, but fixed entry command
ARG	Build-time variables


FROM python:3.10

WORKDIR /app
COPY . .

RUN pip install fastapi uvicorn

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
docker build -t fastapi-app .
docker run -p 8000:8000 fastapi-app
host_port	The port number on your local machine (laptop/server)
container_port	The port number inside the container where the app is running


Docker Compose 
-------------------
environment, ports, volumes, networks, dependencies —
in one single file.
docker-compose up


version: "3.9"

services:
  web:
    build: .                                            -----> Build Image using the Docker file in the Current Directory 
    container_name: fastapi-app
    ports:
      - "8000:8000"
    depends_on:                                        -------> Ensures FastAPI starts after the database
      - db
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/mydb

  db:
    image: postgres:15
    container_name: fastapi-db
    restart: always
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=mydb
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:



docker-compose up	Start all services defined in the file
docker-compose up -d	Run in detached (background) mode
docker-compose down	Stop and remove containers, networks, volumes
docker-compose build	Rebuild all images
docker-compose logs	View combined logs from all services


__slots__
---------------------------------------------
Normally, every Python object (like an instance of a class) stores its attributes in a dictionary (__dict__)
That makes it flexible — you can add or remove attributes dynamically at runtime.
But this flexibility uses more memory and slows down attribute access.


class Person:
    __slots__ = ['name', 'age']   # only these two attributes allowed

    def __init__(self, name, age):
        self.name = name
        self.age = age

p = Person("Sivaraj", 25)
print(p.name)  # Sivaraj


--------------------
import sys

class Normal:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class Slotted:
    __slots__ = ['x', 'y']
    def __init__(self, x, y):
        self.x = x
        self.y = y

n = Normal(10, 20)
s = Slotted(10, 20)

print(sys.getsizeof(n.__dict__))  # More memory
print(sys.getsizeof(s))           # Less memory


list, tuple(shallow immutable, deep immutable), str, set, frozenset(immutable)
---------------------
s.add(10)
l.append(10)


dict 
---------------
len(d) --> 
d1 == d2 --> check two dicts of same length
del d[0] 
del d["sivaraj"]
"d" in dict --> check the keys 
d = dict(a=1,b=2) --> creates new dict
d.popitem() --> removes the last entered items
d.pop('x', 0) --> removes and return the values 


What is shallow copy and deep copy 
----------------
you might be copying the reference or copying the entire structure

copy 
copy.copy()  --> original impact 
copy.deepcopy() --> inner object everything nested , to the other variable --> no original impact, if changes 




Generator 
Iterator 
  def my_iterator(data):
    for item in data:
        yield item 
        
for i in my_iterator([10,20,30]):
    print(i)


a = [10,20,30]

c = iter(a)
print(next(c))
print(next(c))


def my_generator():
    yield 1
    yield 2
    yield 3

gen = my_generator()

print(next(gen))  # 1
print(next(gen))  # 2
print(next(gen))  # 3
# next(gen) → StopIteration


itertor implementation manually 
-------------------------------
class Counter:
    
    def __init__(self,low, high):
        self.low = low 
        self.high = high 
        
    def __iter__(self):
        return self 
        
    def __next__(self):
        if self.low > self.high:
            raise StopIteration
        num = self.low 
        self.low+=1 
        return num 

for i in Counter(1,3):
    print(i)



assert 
--------
x = 10
assert x > 0, "x should be positive"
print("All good!")


Dunder 
-------
This is one of the core ideas in Python’s object model, often called “dunder” (short for double underscore) methods or attributes
“Dunder” means double underscore — it’s short for Double UNDERscore.
__init__, __str__, __repr__, __add__, __len__, __getitem__
__call__
When the object is called like a function
obj()
__enter__ / __exit__
Context manager (with statement)
with obj:
__slots__	Limit allowed attributes (memory optimization)	__slots__ = ('name', 'age')
You can override them in your class to make your objects behave like built-in types (int, list, str, etc)
class Person:
    
    def __init__(self,name):
        self.name = "sivaraj"
        
    def __str__(self):
        return f"Person {self.name}"
        
    def __len__(self):
        return len(self.name)
        
p = Person("Sivaraj")
print(p)
print(len(p))


-------------------------------
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)

    def __str__(self):
        return f"({self.x}, {self.y})"

p1 = Point(2, 3)
p2 = Point(4, 5)

print(p1 + p2)   # Calls __add__ → (6, 8)


__call__
----------------------
class Greeter:
    def __init__(self, name):
        self.name = name
    
    def __call__(self):
        print(f"Hello, {self.name}!")

g = Greeter("Sivaraj")
g()  # Calls __call__ → "Hello, Sivaraj!"


___context_manager____
--------------
class MyContext:
    def __enter__(self):
        print("Entering context")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Exiting context")

with MyContext():
    print("Inside context")

---------------------------------
Overloading Polymorphism - Same name, different behavior 
class Math:
def add(self,a=0,b=0,c=0):
    return a + b + c
m = Math()
print(m.add(2,3))
print(m.add(2,3,4))
-------
Overriding 
class Animal:
    def sound(self):
        print("Animal")

class Dog(Animal):
    def sound(self):
        print("Dog")
d = Dog()
d.sound()
-------
Inheritance
Multiple Inheritance = Derived class inherits from more than one parent 
Multilevel Inheritance - Chain of Inheritance 
Hierarchical Inheritance 
Hybrid Inheritance - Hierachical - Multiple + MultiLevel --> Uses Method Resolution Order (MRO) to decide which parent to call. 






Definitely Adapter Concept
Design Pattern - Behaviour, like that, 
Transformer Architecture layer and components, and splitting of the parameter
Google, Gemini, Anthropic, LLama model prompting 
embedding difference 
Lamaindex state and workflow
Langgraph state and workflow 
sorting 
Pytest, Unit Test, Validation
Python
SQL 
Class OOPS Concept
NLP Metrics, LLM Evaluations for RAG, Agentic AI Applications
Tokenization, Token Count 
Deep Agents Working Prototype 
LangGraph State Concepts - different State Concepts 
sotring and key function --> how to use - Done
Data Base Connection , PostgreSQL, MongoDB Connection - Done
Content Safety Concepts - https://learn.microsoft.com/en-us/azure/ai-foundry/concepts/content-filtering?utm_source=chatgpt.com
                        - https://learn.microsoft.com/en-us/azure/ai-foundry/concepts/content-filtering?utm_source=chatgpt.com
RAI - API's - Responsible AI 
Guardrails 




from collections import Counter 
1. Counter(numbers).most_common(1)
2. counter.most_common()[-1]
3. counter.values()
4. counter.items()

1.from collections import OrderedDict
od = OrderedDict()
od['apple'] = 3
od['banana'] = 5
od['orange'] = 2
2. Comparing two Dict 
od1 = OrderedDict(a=1, b=2)
od2 = OrderedDict(b=2, a=1)
print(od1 == od2)  # False, order is different
3. Inputing the Ordered Dict -> c = OrderedDict([("S","D"),("D","D")])
d = OrderedDict(a=1,b=1,c=2)
b = OrderedDict({})
b["siva"] = "raj"

defaultdict(default_factory, mapping_or_iterable=None)
1.from collections import defaultdict
a = defaultdict(list)
print(l['Sivaraj'])
person_count = defaultdict(int)  # default value = 0
person_count['Alice'] += 1
person_count['Bob'] += 1

from collections import defaultdict
person = {'Alice': 25, 'Bob': 30}
# default value is "unknown" for missing keys
person_dd = defaultdict(lambda: "unknown", person)
print(person_dd['Alice'])   # 25  (existing key)
print(person_dd['Charlie']) # unknown  (missing key)




1.a = float('-inf')

print(a.isalpha())
print(a.isdigit())
print(a.isalnum())
print(a.isdecimal())
print(a.isspace())

1.# True if there is any non-alphanumeric character
has_special = any(not ch.isalnum() for ch in s)  --> any(iterable)

str.count(sub[, start[, end]]) → Count occurrences of substring.
str.find(sub[, start[, end]]) → Index of first occurrence, -1 if not found.
str.rfind(sub[, start[, end]]) → Index of last occurrence, -1 if not found.
str.index(sub[, start[, end]]) → Like find(), but raises ValueError if not found.
str.rindex(sub[, start[, end]]) → Like rfind(), but raises ValueError if not found.
str.startswith(prefix[, start[, end]]) → Checks if string starts with prefix.
str.endswith(suffix[, start[, end]]) → Checks if string ends with suffix.
str.partition(sep) → Splits into tuple (before, sep, after) at first occurrence.
str.rpartition(sep) → Splits at last occurrence.
str.split(sep=None, maxsplit=-1) → Splits string into list.
str.rsplit(sep=None, maxsplit=-1) → Splits string from right.
str.splitlines(keepends=False) → Splits string at line breaks.
str.replace(old, new[, count]) → Replaces occurrences of a substring.
Trimming/Stripping
str.strip([chars]) → Removes leading/trailing whitespace or characters.
str.lstrip([chars]) → Removes leading characters.
str.rstrip([chars]) → Removes trailing characters.
str.removeprefix(prefix) → Removes prefix if present (Python 3.9+).
str.removesuffix(suffix) → Removes suffix if present (Python 3.9+).
Joining/Formatting
str.join(iterable) → Joins elements of iterable with the string as separator.
str.format(*args, **kwargs) → Formats string with placeholders.
str.format_map(mapping) → Like format(), but uses a mapping (dict).
str.maketrans(x, y=None, z='') → Returns translation table for translate().
str.translate(table) → Translates string using a translation table.
Padding/Aligning
str.center(width[, fillchar]) → Centers string.
str.ljust(width[, fillchar]) → Left-aligns string.
str.rjust(width[, fillchar]) → Right-aligns string.
str.zfill(width) → Pads string with zeros on the left.
Encoding/Decoding
str.encode(encoding='utf-8', errors='strict') → Encodes string to bytes.
str.decode() → Only on bytes, not string.
Other Useful Methods
str.isnumeric() → Checks if all chars are numeric.
str.isprintable() → Checks if all chars are printable.
str.expandtabs(tabsize=8) → Replaces tabs \t with spaces.


complement sum 
a = [2,7,6,4]
target = 9 
num_maps = {}
for i,num in enumerate(a):
    complement = target - num 
    if complement in num_maps:
        print ([num_maps[complement],i])
        break
    num_maps[num] = i 

#Identifying the Duplicates 
a = [1,3,2,4,2]
seen = set()
for i in a:
    if i in seen:
        print("True") 
        break
    seen.add(i) 


#Maximum Common Subarray 
#Intersection of Two Arrays 
a = [1,2,4,235]
b = [2,4]   

for i in range(0,len(b)):
    for j in range(0,len(a)):
        #print(a[i:j+1])
        if a[i:j] == b:
            print(True)
        #if a[i:j] in b:
            max_results = a[i:j]
print(max_results)


#Intersection 
from collections import Counter


a = [1,3,43,5,3,3]
b = [3,4,5,3]

def Intersection(nums1,nums2):
    counts = Counter(nums2)
    results = []
    for i in nums1:
        if counts[i] > 0:
            results.append(i)
            counts[i]-=1
    return results
c = Intersection(a,b)
print(c)



1. Decorator 
def dec(func):
    def wrapper():
        print("Before the main function")
        func()
    return wrapper
    
    
@dec
def say_hello():
    print("This is the main function")
    
say_hello()

# Selection Sorting  ---> Playing with Index
2 for loop is for looping
a = [1,3,54,3,5]
n = len(a)
for i in range(n):
    min_index = i 
    for j in range(i+1,n):
        if a[min_index] > a[j]:
            min_index = j 
    a[min_index],a[i] = a[i],a[min_index]
print(a)

# Insertion Sorting  ---> Playing with Key 
2 for loop is for updating the min_index
arr= [1,3,2,4,3,5,5]
n = len(arr)
for i in range(1,n):
    key = arr[i]
    j = i - 1 
    while j > 0 and arr[j] > key:
        arr[j+1] = arr[j]
        j-=1 
    arr[j+1] = key 
print(arr)

# Quick Sorting -> Playing with Recursion 
a = [1,3,5,3,5,2,4,3]

def Quick(a):
    if len(a) <= 1:
        return a 
    pivot = a[len(a)//2]
    left = [i for i in a if i<pivot]
    middle = [i for i in a if i==pivot]
    right = [i for i in a if i>pivot]
    return Quick(left) + middle + Quick(right)

d = Quick(a)
print(d)

#Merge Sorting 

def Merge(arr):
    if len(arr) <=1:
        return arr
    middle = len(arr)//2 
    left   = Merge(arr[:middle])
    right  = Merge(arr[middle:])

    retrun Merge_sort(left,right) 
def Merge_sort(left,right):
    sorted_list = [] 
    i = j = 0 
    While i < len(left) and j < len(right):
        if left[i] <  right[j]:
            sorted_list.append(left[i])
            i+=1  
        else:
            sorted_list.append(right[j])
            j+=1 
    sorted_list.extend(left[i:])
    sorted_list.exten(right[j:])

Best Time to Buy and Sell Stock   ---> Set the min_price by looping, that is buy 
prices = [13,2,54,2,5,3]
max_profit = 0 
min_price = float('inf')

for i in range(len(prices)):
    if prices[i] < min_price:
        min_price = prices[i] #Buy
    else: 
        max_profit = max(max_profit, prices[i] - min_price)
print(max_profit)


Maximum Subarray --->       Finding the Maximum Subarray --> continuous Sub Array 
Find the contiguous subarray (containing at least one number) which has the largest sum, and return its sum
This is a classic Dynamic Programming problem, known as Kadane's Algorithm.
You track the maximum sum ending at each index, and the global maximum so far.
# Finding the Maximum SubArray 

a = [1,3,-4,3,5,3,5]
max_global = max_current = a[0]
for i in range(1,len(a)):
    max_current = max(a[i],max_current + a[i])
    max_global = max(max_global, max_current)
print(max_global)
print(sum(a))


Binary Search ---> 
# Binary Search  --> left, right 


def search(nums,target):
    left, right = 0,len(nums)-1
    
    while left <= right:
        mid = (left+right)//2
        if nums[mid] == target:
            return num[mid]
        elif nums[left] < target:
            left = mid + 1 
        else
            right = mid -1 
    return -1

Top K Frequent Elements
number of top of K frequent elements 
from collections import defaultdict, Counter

def topKFrequent(nums, k):
    freq_map = Counter(nums)
    bucket = [[] for _ in range(len(nums) + 1)]

    for num, freq in freq_map.items():
        bucket[freq].append(num)

    result = []
    for freq in range(len(bucket) - 1, 0, -1):
        for num in bucket[freq]:
            result.append(num)
            if len(result) == k:
                return result


Backtracking (DFS Recursion)
Subsets
❓ Problem Statement:
Given an integer array nums of unique elements, return all possible subsets (the power set).
The solution must not contain duplicate subsets, and you can return the answer in any order.
We'll build subsets by recursively adding or skipping each element.

Recursively adding or skipping the element
def subsets(nums):
    res = []

    def backtrack(start, path):
        res.append(path[:])  # Add a copy of the current subset
        for i in range(start, len(nums)):
            path.append(nums[i])            # Choose
            backtrack(i + 1, path)          # Explore
            path.pop()                      # Un-choose (backtrack)

    backtrack(0, [])
    return res

def subsets(nums):
    res = [[]]
    for num in nums:
        res = res + [item + [num] for item in res]
    return res

Longest Common_SubString - 

def longest_common_substring(s1, s2):
    s1, s2 = s1.lower(), s2.lower()  # case-insensitive
    longest = ""
    n = len(s1)
    if len(s1) < len(s2):
        n = len(s2)
        s1,s2 = s2,s1
    for i in range(n):
        for j in range(i + 1, n + 1):
            sub = s1[i:j]
            if sub in s2 and len(sub) > len(longest):
                longest = sub
    return longest, len(longest)
    
a = longest_common_substring("varat","Sivaraj")
print(a)









Buy --> finding the min_price 
SubArray  -> Kadane's Algo -> simple, current, global 
binary_search -> simple 


    
    
    




To Revise 
popitem
iterator 
generator 


1.RAG - Different Chunking, VB, Retrieval, Caching, Fallback, Prompting, Testing, LangGraph 
2.Previous Project Compliance Ready Project - Obscure, Data Privacy and Governance , DDD Design , FastAPI, Azure Service to Deploy, Onion Layer Approach of System, Adapter , Controller, 
3.General GenAI Topic - Different Parameter, Transformer Usage and Mathematical, Agentic AI
4.General Machine Learning - Trade-Off, Bias, Variance, Gradient Descent, Not Convergence Reason, Neural Network
5.Software Engineering Principles - SOLID,KISS, Design Pattern, LLD, HLD[Architecting]

Where I will Stuck 
1. In Services I have Used - Memory for Agent[How I Stored the Response]
2. In Coding related to framework Specific 
3. In FastAPI & ReactJS - Related to web technology - Authentication, Authorization, Fallback, Callback, Caching, Load Balancing, DataBase Optimizing(Indexing)
4. Actual Deployment of my Project 
5. Responsible AI Approach 

Services I used 
1. Postgresql in the Azure - used to store the Converstation History [Window Buffer, Semanitc, Summarizing, Long-Term[Need Vector Store and Indexing to Search], Short-Term]
2. Redis for Caching the LLM Response - in the Azure 
3. MongoDB Vector Store 
4. 

----------------------------------------------
Front End [FC, Functional Component is very important 
DOM[object-based representation of that HTML.][tree of objects that represents the structure and content of a webpage]-- Tree Like Structure In Memory - JavaScript will Talk & Interact -- React - Virtual DOM 

<!DOCTYPE html>
<html>
  <head>
    <title>DOM Example</title>
  </head>
  <body>
    <h1 id="title">Hello World</h1>
    <button id="btn">Click Me</button>

    <script>
      // Access the DOM element
      const title = document.getElementById("title");
      const button = document.getElementById("btn");

      // Add a click event
      button.addEventListener("click", function() {
        // Change the text of the h1
        title.textContent = "You clicked the button!";
      });
    </script>
  </body>
</html>


React Functional Component 
======================
1.React.FC stands for React Functional Component.
2.It’s a generic type provided by React to type a functional component.
3.Alternate way without React.FC
const Greeting = ({ name, age }: GreetingProps) => {
  return <h1>Hello {name}! {age && `You are ${age} years old.`}</h1>;
};


-----------------------------
document.getElementById
document.querySelector
document.querySelector("button")
document.getElementsByClassName("item"); ---> HTML Collection
document.getElementsByTagName("p");   
                           css-selector
document.querySelector(".container p"); - Get First Matching Element 
document.querySelectorAll("li.active");

---------------------------
Manipulation 
element.textContent = "New Text";
element.innerHTML = "<b>Bold Text</b>";
element.style.color = "red";
element.style.background = "yellow";
element.setAttribute("src", "image.png");
let value = element.getAttribute("src");

let newDiv = document.createElement("div");
newDiv.textContent = "Hello!";
document.body.appendChild(newDiv);

element.remove();

append() and prepend() ---> flexible than appendChild 

----------------------
let 
const


----------------------Listen for events click, mouseover, keydown, 
event, callback function
element.addEventListener("event", function)

button.addEventListener("click", function() {
        // Change the text of the h1
        title.textContent = "You clicked the button!";
      });

element.addEventListener("click", () => {
  console.log("Clicked!");
});

Remove Event 
function sayHi() { console.log("Hi"); }
element.addEventListener("click", sayHi);
element.removeEventListener("click", sayHi);

click
mouseover / mouseout
keydown / keyup
submit
change
input


-----------------
console.log(p.textContent)

-------------------
 alert("Button was clicked!");


Interface is blueprint of the object 
------------------
interface User {
  id: number;
  name: string;
  isAdmin: boolean;
}

const user1: User = { id: 1, name: "Alice", isAdmin: true }; ✅
const user2: User = { id: 2, name: "Bob" }; ❌ // Error: missing isAdmin


Both work, but:
interface = extendable (great for objects, props).
type = more flexible (unions, intersections).
👉 In React props, people often use interface, but type works too.
React Props 
---------------
In React, we often pass props to components.
TypeScript + interface = makes sure props are the right shape.
import React from "react";

// Step 1: Define interface for props
interface GreetingProps {
  name: string;
  age?: number;  // optional prop
}

import React from "react";

// Step 1: Define interface for props
interface GreetingProps {
  name: string;
  age?: number;  // optional prop
}

// Step 2: Use it in the component
const Greeting: React.FC<GreetingProps> = ({ name, age }) => {
  return (
    <h1>
      Hello {name}! {age && `You are ${age} years old.`}
    </h1>
  );
};

// Step 3: Use the component
export default function App() {
  return (
    <div>
      <Greeting name="Alice" age={25} />
      <Greeting name="Bob" /> {/* works because age is optional */}
    </div>
  );
}




Typing State with Interface 
-------------------------
interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

const TodoApp: React.FC = () => {
  const [todos, setTodos] = React.useState<Todo[]>([]);

  return (
    <div>
      {todos.map(todo => (
        <p key={todo.id}>
          {todo.text} - {todo.completed ? "Done" : "Pending"}
        </p>
      ))}
    </div>
  );
};



Example 3: Interface for Event Handlers
----------------------------
interface ButtonProps {
  label: string;
  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;
}

const MyButton: React.FC<ButtonProps> = ({ label, onClick }) => {
  return <button onClick={onClick}>{label}</button>;
};














---------when you already have one element and want to navigate to related elements in the DOM tree.
DOM Traversal Moving around the Tree 
element.parentElement     // Get parent
element.children          // Get all children
element.firstElementChild // Get first child
element.lastElementChild  // Get last child
element.nextElementSibling // Next element
element.previousElementSibling // Previous element





Examples: 
Adding New Element 
<!DOCTYPE html>
<html>
  <body>
    <h1>My Page</h1>
    <button id="btn">Add Item</button>
    <ul id="list"></ul>

    <script>
      const button = document.getElementById("btn");
      const list = document.getElementById("list");

      button.addEventListener("click", function() {
        // 1. Create a new list item
        let newItem = document.createElement("li");

        // 2. Add content
        newItem.textContent = "New List Item";

        // 3. Append it to the UL
        list.appendChild(newItem);
      });
    </script>
  </body>
</html>

InnerHTML
-------------
<ul id="list"></ul>

<script>
  let list = document.getElementById("list");

  // Add HTML directly
  list.innerHTML += "<li>Item added with innerHTML</li>";
</script>


Inside Div, span 
--------------
let span = document.querySelector("span");
let parentDiv = span.parentElement;
parentDiv.style.border = "1px solid red";

Inside UL, LI
-------
let list = document.querySelector("ul");
for (let child of list.children) {
  child.style.color = "blue";
}


Fist and Last Child
-----------
let list = document.querySelector("ul");
list.firstElementChild.style.fontWeight = "bold";
list.lastElementChild.style.fontStyle = "italic";


move between the element quickly in the same element
-----------------------------------------------
let firstItem = document.querySelector("li");
let secondItem = firstItem.nextElementSibling;
secondItem.style.background = "yellow";

Event handling
Form navigation: If you want to move to the next input field (nextElementSibling) after validation.
Dynamic Styling: Change first/last/neighbor elements without using IDs or classes
Building components: Traversing the DOM tree is often used in UI libraries, custom scripts, or when working with deeply nested HTML.


Interview Basic Question 
---------------
function hello() {
return "hello!";
}

const sayhello = () => {
return "Hello";
};

const sayhello = () => "Hello";

const sayhello = x => x*x;
console.log(square(4));
const add = (a,b) => a+b;
const makeUser (name,age) => ({name, age});
const numbers = [1,3,4,5];
const doubled = numbers.map(num => num*2);


{todos.map(todo => ( <p key = {todo.id}> {todo.text} - {todo.completed ? "Done": "Pending"} </p> ) ) }


React Arrow functions for components & Event Handlers 
cost Greeting = ({name}:{name: string}) => <h1> Hello {name}</h1>;
<button onClick={() => alert("clicked")}>Click Me</button> 
Different Scenarios for Arrow Functions
Shorthand for simple functions → (a, b) => a + b
Callbacks (map, filter, reduce, forEach, etc.) → arr.map(x => x * 2)
Event handlers in React → <button onClick={() => ...}>
Functional React components → const App = () => <div>Hello</div>
Avoiding this issues in objects/classes → arrow keeps lexical this
function Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // 'this' refers to Person, not setInterval
    console.log(this.age);
  }, 1000);
}

new Person();
If we had used a normal function inside setInterval, this would not work as expected.

1.Props (short for “properties”) are how you pass data from a parent component to a child component.
2.Parent - Child Communication 
  Props let parents send data to children. 
function App() {
  return <Greeting name="Sivaraj" />;
}
3.Stateless → Controlled by Parent
Props make components stateless and predictable.
Example: Parent controls what child displays.

Props vs State 
const Counter = ({ start }: { start: number }) => {
  const [count, setCount] = React.useState(start);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
};
start (prop) = given by parent
count (state) = managed inside Counter

We use props to make components reusable, dynamic, and customizable — they are the "inputs" that flow down from parent to child in React.




------------------------------------------------------------------------------------------------------------
Structure 
Index.jsx -->  
               Have App, 
               Have DOM Element 
               create the root 
               and pass this root to the index.HTML 
