DOM

Next.js and Nest.js
Next.js - A React framework created by Vercel. Designed for building frontend & “full-stackish” web applications with React. Provides benefits like server-side rendering (SSR), static site generation (SSG), routing, etc.
https://www.contentful.com/blog/nestjs-vs-nextjs/?utm_source=chatgpt.com
https://en.wikipedia.org/wiki/Next.js?utm_source=chatgpt.com
https://www.aalpha.net/blog/nextjs-vs-nestjs-difference/?utm_source=chatgpt.com

Nest.js - A backend (server-side) application framework on Node.js, built with/for TypeScript. Inspired by Angular’s architecture (modules, dependency injection, decorators), aimed at building scalable, maintainable server apps and microservices.
https://www.contentful.com/blog/nestjs-vs-nextjs/?utm_source=chatgpt.com


Next.js - Primary Role
Frontend UI, React components, pages, rendering, optimized for SEO, user facing content. It can have backend logic via API routes, SSR etc., but that backend capability is more lightweight.
Rendering / UI
Provides SSR, SSG, ISR (Incremental Static Regeneration), client side rendering, etc. Also handles UI + routing via React.
Architecture & Patterns
Less opinionated about backend structure; has file-based routing for pages and API routes; React component model.
Learning Curve
Easier if you know React / JS. Lower barrier especially for frontend tasks.
Strengths
SEO, performance for web content, static sites, pages with dynamic content but focusing on frontend experience. Rapid UI development.
Use Cases
Marketing sites, landing pages, blogs, dashboards, e-commerce frontends, where page load, SEO, stable UI matter.


Nest.js - Primary Role 
Fully backend: APIs, business logic, microservices, databases, WebSockets, GraphQL etc. Meant for larger server-side concerns.
No built-in UI / frontend component. It’s not for rendering pages in React (though you could combine with a frontend).
More opinionated: modules, controllers, services, dependency injection, interceptors, pipes etc. Gives a lot of structure and conventions.
Steeper, especially if you’re new to strongly typed patterns, dependency injection, modular architecture. More boilerplate sometimes.
https://medium.com/%40chauhananubhav16/nestjs-vs-next-js-a-comprehensive-comparison-22da32d5b8f0?utm_source=chatgpt.com
https://www.spec-india.com/blog/nestjs-vs-nextjs?utm_source=chatgpt.com
Scalable backend services, APIs, microservices, real-time features, strong maintainability in large codebases. Good testability, structure.
Backend for mobile / web applications, REST / GraphQL, applications needing real-time / sockets, enterprise systems, microservices architectures.

When to use each / Can they work together
If your project is mostly frontend, or you want a UI with good SEO + fast performance, Next.js is a strong choice.
If your project needs heavy backend logic, complex server-side operations, many endpoints, integrations with database, microservices, you’ll want Nest.js.

Trade-offs / What to watch out for
If you use Next.js for backend-type logic beyond “just API routes”, you may run into maintainability issues or performance overheads, since it's not as richly structured for backend concerns.
Using Nest.js adds boilerplate / structure; for small/simple projects the overhead might outweigh benefits.
Deployment and hosting requirements differ. Next.js apps often assume you have a hosting solution that supports SSR, static builds, etc., while Nest.js is purely server side, needing e.g. Node server, maybe microservices, etc.


DOM [built-in JavaScript methods provided by the browser through the DOM API.] -browser’s JavaScript engine + DOM API.
    [you select elements and manipulate them dynamically with JavaScript.]
    [The DOM is a tree of objects that represents the structure and content of a webpage, which your code can manipulate.]
The DOM is not the HTML file itself.
It’s the browser’s live, object-based representation of that HTML.
You use code (like JavaScript’s document object) to read or modify it.

The browser reads it and turns it into a DOM tree in memory:
Document
 └── html
      └── body
          ├── h1 ("Hello")
          └── button ("Click me")
Now in coding, you can interact with this DOM using JavaScript:
// Find the button
let btn = document.querySelector("button");

// Change its text
btn.textContent = "Clicked!";

---------------------------------------
DOM = Document Object Model
It’s a programming interface (API) that lets you use code (like JavaScript, Python, etc. in a browser context) to work with HTML or XML documents.
----------------------------------------



Eg:<button id="btn">Click Me</button>

<script>
  let button = document.getElementById("btn");

  button.addEventListener("click", function() {
    alert("Button was clicked!");
  });
</script>

Tips
**element.addEventListener("eventType", callbackFunction);

Listen for Events
click, mouseover, keydown

Built-in JavaScript methods provided by the browser through the DOM API.
1. document.getElementById("id")
Purpose: Finds an element in the DOM by its id.
Returns: A reference to that element (as a JavaScript object).
<p id="para">Hello</p>

<script>
  let p = document.getElementById("para");
  console.log(p.textContent); // Output: Hello
</script>

Benefit
If you change the DOM directly, the browser has to repaint the screen and recalculate styles/layout every time

-------------------------------------------------------------------------------------------------------------
DOM Selection Methods
document.getElementById("id") → Get element by ID.
document.getElementById("title");
document.getElementsByClassName("class") → Get elements by class (HTMLCollection).
document.getElementsByClassName("item");
document.getElementsByTagName("tag") → Get elements by tag name.
document.getElementsByTagName("p");
document.querySelector("css-selector") → Get first matching element.
document.querySelector(".container p");
document.querySelectorAll("css-selector") → Get all matching elements (NodeList).
document.querySelectorAll("li.active");
DOM Manipulation Methods
------------------------
Change content
element.textContent = "New Text";
element.innerHTML = "<b>Bold Text</b>";
innerHTML (String-Based Way)
You directly replace or add raw HTML markup as a string.
Faster to write, but less safe (can cause security issues if input is from users — XSS attacks).
<ul id="list"></ul>

<script>
  let list = document.getElementById("list");

  // Add HTML directly
  list.innerHTML += "<li>Item added with innerHTML</li>";
</script>
modern alternatives (like append() and prepend()) that are more flexible than appendChild
Change style
element.style.color = "red";
element.style.background = "yellow";
Change attributes
element.setAttribute("src", "image.png");
let value = element.getAttribute("src");
Create & add elements
let newDiv = document.createElement("div");
newDiv.textContent = "Hello!";
document.body.appendChild(newDiv);   -----> appendChild
this is one of the most important DOM methods for creating and adding elements dynamically.
 --------------Create something → Pick a parent → Attach it inside the parent-----------------
-----------------Now choose a parent (e.g., document.body or another container), and attach the new element:-------
<!DOCTYPE html>
<html>
  <body>
    <h1>My Page</h1>
    <button id="btn">Add Item</button>
    <ul id="list"></ul>

    <script>
      const button = document.getElementById("btn");
      const list = document.getElementById("list");

      button.addEventListener("click", function() {
        // 1. Create a new list item
        let newItem = document.createElement("li");

        // 2. Add content
        newItem.textContent = "New List Item";

        // 3. Append it to the UL
        list.appendChild(newItem);
      });
    </script>
  </body>
</html>
Remove elements
element.remove();

Event Handling
1.Add event
element.addEventListener("click", () => {
  console.log("Clicked!");
});
2.Remove event
function sayHi() { console.log("Hi"); }
element.addEventListener("click", sayHi);
element.removeEventListener("click", sayHi);
Common events
click
mouseover / mouseout
keydown / keyup
submit
change
input

DOM Traversal (Moving around the tree)
element.parentElement     // Get parent
element.children          // Get all children
element.firstElementChild // Get first child
element.lastElementChild  // Get last child
element.nextElementSibling // Next element
element.previousElementSibling // Previous element

getElementById / querySelector → Find elements
.textContent / .style → Change elements
createElement / appendChild → Add elements
remove() → Delete elements
addEventListener → React to events


DOM Traversal Properties  [when and why we use them.]
------------------------
when you already have one element and want to navigate to related elements in the DOM tree.
1.element.parentElement
Used when you have a child but need to access its parent
Example: You click on a <span> inside a <div>, but you want to style the parent <div>
let span = document.querySelector("span");
let parentDiv = span.parentElement;
parentDiv.style.border = "1px solid red";
2.element.children
Used when you want all direct children of an element.
Example: Style all <li> inside a <ul>
let list = document.querySelector("ul");
for (let child of list.children) {
  child.style.color = "blue";
}
3.element.firstElementChild & element.lastElementChild
Used when you only need the first or last child quickly.
Example: Highlight the first and last items in a list.
let list = document.querySelector("ul");
list.firstElementChild.style.fontWeight = "bold";
list.lastElementChild.style.fontStyle = "italic";
4.element.nextElementSibling & element.previousElementSibling
Used to move sideways in the DOM (between elements on the same level).
let firstItem = document.querySelector("li");
let secondItem = firstItem.nextElementSibling;
secondItem.style.background = "yellow";

Event handling: When an event happens on one element but you need related elements.
Example: Clicking a "Delete" button inside a table row → remove the entire row using button.parentElement.
Form navigation: If you want to move to the next input field (nextElementSibling) after validation.
Dynamic styling: Change first/last/neighbor elements without using IDs or classes
Building components: Traversing the DOM tree is often used in UI libraries, custom scripts, or when working with deeply nested HTML.

Interface 
---------
1.An interface is like a blueprint for an object.
2.It defines what properties (and types) an object should have, but not the actual values.

interface User {
  id: number;
  name: string;
  isAdmin: boolean;
}

const user1: User = { id: 1, name: "Alice", isAdmin: true }; ✅
const user2: User = { id: 2, name: "Bob" }; ❌ // Error: missing isAdmin

Why interfaces in React?
In React, we often pass props to components.
TypeScript + interface = makes sure props are the right shape.

---------------------------------------------------
import React from "react";

// Step 1: Define interface for props
interface GreetingProps {
  name: string;
  age?: number;  // optional prop
}

// Step 2: Use it in the component
const Greeting: React.FC<GreetingProps> = ({ name, age }) => {
  return (
    <h1>
      Hello {name}! {age && `You are ${age} years old.`}
    </h1>
  );
};

// Step 3: Use the component
export default function App() {
  return (
    <div>
      <Greeting name="Alice" age={25} />
      <Greeting name="Bob" /> {/* works because age is optional */}
    </div>
  );
}

1.React.FC stands for React Functional Component.
2.It’s a generic type provided by React to type a functional component.
3.When you write React.FC<GreetingProps>, you’re telling TypeScript
4."Greeting is a functional component that accepts props of type GreetingProps."

Alternative way (without React.FC):
const Greeting = ({ name, age }: GreetingProps) => {
  return <h1>Hello {name}! {age && `You are ${age} years old.`}</h1>;
};



-----------------------------------------------------
Typing State with Interface

interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

const TodoApp: React.FC = () => {
  const [todos, setTodos] = React.useState<Todo[]>([]);

  return (
    <div>
      {todos.map(todo => (
        <p key={todo.id}>
          {todo.text} - {todo.completed ? "Done" : "Pending"}
        </p>
      ))}
    </div>
  );
};
Here, todos must always be an array of objects shaped like Todo
-----------------------------------------------------------------
Example 3: Interface for Event Handlers

interface ButtonProps {
  label: string;
  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;
}

const MyButton: React.FC<ButtonProps> = ({ label, onClick }) => {
  return <button onClick={onClick}>{label}</button>;
};

**Why not just use type instead of interface
Both work, but:
interface = extendable (great for objects, props).
type = more flexible (unions, intersections).


An interface in React + TypeScript defines the shape of props, state, or objects.
It’s like saying: “This component only accepts props that look like this.”
Helps catch bugs early and makes code easier to understand.


---------------------------------
Arrow functions (() => {}) are modern JavaScript functions introduced in ES6
-------------------------------------------------
// Traditional function
function sayHello() {
  return "Hello!";
}

// Arrow function
const sayHello = () => {
  return "Hello!";
};

Short Version Implicit Return 
const sayHello = () => "Hello!";

1.Arrow Functions with Parameters
// One parameter (no need for parentheses)
const square = x => x * x;
console.log(square(4)); // 16
// Multiple parameters
const add = (a, b) => a + b;
console.log(add(2, 3)); // 5
2.Returning Objects
Important: Wrap objects in () when returning directly.
const makeUser = (name, age) => ({ name, age });
console.log(makeUser("Alice", 25)); // { name: "Alice", age: 25 }
4. Arrow Functions in Callbacks
Arrow functions are great for short, inline functions.
const numbers = [1, 2, 3, 4];

// Using map with arrow
const doubled = numbers.map(num => num * 2);
console.log(doubled); // [2, 4, 6, 8]
5. Arrow Functions in React
React loves arrow functions for components & event handlers.
const Greeting = ({ name }: { name: string }) => <h1>Hello {name}</h1>;
-----
Step 1: Without Destructuring
Normally, a React functional component receives props:
const Greeting = (props: { name: string }) => {
  return <h1>Hello {props.name}</h1>;
};
props is an object.
Step 2: Destructuring Props
Instead of writing props.name, we can destructure props directly in the function parameter:
const Greeting = ({ name }: { name: string }) => {
  return <h1>Hello {name}</h1>;
};
Here:
{ name } → pulls name directly out of props.
: { name: string } → tells TypeScript that this destructured object must contain a string name.
So instead of props.name, you can directly use name.
Step 3: Using an Interface (Cleaner Way)
Often, we declare a type or interface for props:
interface GreetingProps {
  name: string;
}

const Greeting = ({ name }: GreetingProps) => {
  return <h1>Hello {name}</h1>;
};
Step 4: Usage
<Greeting name="Alice" />
If you try <Greeting /> without passing name, TypeScript will give an error.
If you pass <Greeting name={123} />, also an error, since it expects a string.
Step 5: Short Cut of using Props - Alternative Way 
const Greeting = (props: { name: string }) => {
  const { name } = props;
  return <h1>Hello {name}</h1>;
};


Event Handler
<button onClick={() => alert("Clicked!")}>Click Me</button>
6. Lexical this (Important Difference)
Unlike normal functions, arrow functions don’t have their own this.
They use this from the surrounding scope.
function Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // 'this' refers to Person, not setInterval
    console.log(this.age);
  }, 1000);
}

new Person();
If we had used a normal function inside setInterval, this would not work as expected.

Why Do We Use Props in Components
---------------------------------
1.Props (short for “properties”) are how you pass data from a parent component to a child component.
2.Think of them like function parameters but for React components.

Analogy 
-------
A Function takes arguments
function greet(name: string) {
  return `Hello ${name}`;
}

greet("Alice"); // Hello Alice

A React component takes props:
const Greeting = ({ name }: { name: string }) => <h1>Hello {name}</h1>;
<Greeting name="Alice" />  // renders: Hello Alice

In both cases, you provide input → it produces output.

Key Reasons We Use Props
1.Reusability
One component can be reused with different data.
<Greeting name="Alice" />
<Greeting name="Bob" />
<Greeting name="Charlie" />
2.Dynamic Content
Instead of hardcoding, you can pass dynamic values:
<Greeting name={user.username} />
3.Parent → Child Communication
Props let parents send data to children.
function App() {
  return <Greeting name="Sivaraj" />;
}

Component Customization
You can make components behave differently using props.
const Button = ({ label, color }: { label: string; color: string }) => (
  <button style={{ backgroundColor: color }}>{label}</button>
);

<Button label="Save" color="green" />
<Button label="Delete" color="red" />

Stateless → Controlled by Parent
Props make components stateless and predictable.
Example: Parent controls what child displays.

Props vs State
Props: Passed into a component, controlled by the parent.
State: Managed inside a component, controlled by the component itself.


const Counter = ({ start }: { start: number }) => {
  const [count, setCount] = React.useState(start);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
};

Here:
start (prop) = given by parent
count (state) = managed inside Counter

We use props to make components reusable, dynamic, and customizable — they are the "inputs" that flow down from parent to child in React.





