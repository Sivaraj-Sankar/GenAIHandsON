1.Modern React Hooks: Components use React hooks like useState, useEffect, and custom hooks **ThreadContext.tsx:19
2.Radix UI components for accessible UI primitives - keyboard navigation, ARIA attributes, screen reader support, focus management


3.State
4.Props = what you get (from outside).
5.State = what you manage (inside yourself).
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0); // count = state

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}

import React from "react";
import { createRoot } from "react-dom/client";
import Counter from "./Counter"; // 👈 assuming your file is Counter.js

function App() {
  return (
    <div>
      <h1>My First React App</h1>
      <Counter /> {/* 👈 This is how you "call" Counter */}
    </div>
  );
}

const root = createRoot(document.getElementById("root"));
root.render(<App />);


Prop
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}

// Using Greeting with different props
<Greeting name="Alice" />
<Greeting name="Bob" />
name is a prop.
Greeting component cannot change props.name — it only uses it.


6.Routing
npm install react-router-dom
npm install -D @types/react-router-dom
import { BrowserRouter, Routes, Route } from "react-router-dom";
import Home from "./pages/Home";
import About from "./pages/About";
import Contact from "./pages/Contact";

In your App.tsx, wrap your app with BrowserRouter and define routes:
function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/contact" element={<Contact />} />
      </Routes>
    </BrowserRouter>
  );
}
/ → Home page
/about → About page
/contact → Contact page
export default App;

Navigation Links
To move between pages, use <Link> or <NavLink> instead of <a> tags (so React doesn’t reload the page):
import { Link } from "react-router-dom";

function Navbar() {
  return (
    <nav>
      <Link to="/">Home</Link> |{" "}
      <Link to="/about">About</Link> |{" "}
      <Link to="/contact">Contact</Link>
    </nav>
  );
}

export default Navbar;

4. Programmatic Navigation
Sometimes you need to navigate after an action (e.g., form submit).
For that, use the useNavigate hook:
import { useNavigate } from "react-router-dom";

function Contact() {
  const navigate = useNavigate();

  const handleSubmit = () => {
    // after submitting, go to Home
    navigate("/");
  };

  return (
    <div>
      <h2>Contact Page</h2>
      <button onClick={handleSubmit}>Go Home</button>
    </div>
  );
}

export default Contact;

5. Dynamic Routes (with Params)
You can define routes with parameters:
<Route path="/users/:id" element={<UserProfile />} />
Inside UserProfile.tsx:
import { useParams } from "react-router-dom";

function UserProfile() {
  const { id } = useParams<{ id: string }>();
  return <h2>User Profile for ID: {id}</h2>;
}

7. SideBar 
+--------------------------------+
| SidebarHeader                  |
| +----------------------------+ |
| | SidebarMenu                | |
| | +------------------------+ | |
| | | SidebarMenuItem        | | |
| | | +--------------------+ | | |
| | | | SidebarMenuButton   | | | |
| | | | +----------------+ | | | |
| | | | | Link           | | | | |
| | | | | +------------+ | | | | |
| | | | | | Icon       | | | | | |
| | | | | | MessagesSquare   | | |
| | | | | +------------+ | | | | |
| | | | | | Text       | | | | | |
| | | | | | "assistant-ui" | | | |
| | | | +----------------+ | | | |
| | | +--------------------+ | | |
| | +------------------------+ | |
| +----------------------------+ |
+--------------------------------+
| SidebarContent                 |
| +----------------------------+ |
| | ThreadList                 | |
| +----------------------------+ |
+--------------------------------+
| SidebarRail                    |
| (Optional slim navigation)     |
+--------------------------------+
| SidebarFooter                  |
| +----------------------------+ |
| | SidebarMenu                | |
| | +------------------------+ | |
| | | SidebarMenuItem        | | |
| | | +--------------------+ | | |
| | | | SidebarMenuButton   | | | |
| | | | +----------------+ | | | |
| | | | | Link           | | | | |
| | | | | +------------+ | | | | |
| | | | | | Icon       | | | | | |
| | | | | | Github     | | | | | |
| | | | | +------------+ | | | | |
| | | | | | Text       | | | | | |
| | | | | | "GitHub"   | | | | | |
| | | | | | "View Source" | | | |
| | | | +----------------+ | | | |
| | | +--------------------+ | | |
| | +------------------------+ | |
+--------------------------------+
Header is at the top, Footer at the bottom.
Content is scrollable in the middle.
SidebarRail is optional, could be a thin vertical bar on the side.
Each menu item consists of an icon and text stacked vertically.


Sidebar
│
├─ SidebarHeader
│  └─ SidebarMenu
│     └─ SidebarMenuItem
│        └─ SidebarMenuButton
│           └─ Link (https://assistant-ui.com)
│              ├─ Icon container (MessagesSquare)
│              └─ Text container
│                 └─ "assistant-ui"
│
├─ SidebarContent
│  └─ ThreadList
│
├─ SidebarRail
│  (empty in this code, acts as a rail/navigation)
│
└─ SidebarFooter
   └─ SidebarMenu
      └─ SidebarMenuItem
         └─ SidebarMenuButton
            └─ Link (https://github.com/assistant-ui/assistant-ui)
               ├─ Icon container (Github)
               └─ Text container
                  ├─ "GitHub"
                  └─ "View Source"


Props 
<AppSidebar color="blue" collapsed={true}>
        │
        │  (all props collected into `props` via ...props)
        ▼
function AppSidebar({ ...props })
        │
        │  (props are spread onto Sidebar)
        ▼
<Sidebar {...props}>
        │
        │  Sidebar receives:
        │  - color="blue"
        │  - collapsed={true}
        │
        │  Sidebar handles these props internally:
        │    ├─ SidebarHeader
        │    ├─ SidebarContent
        │    ├─ SidebarRail
        │    └─ SidebarFooter
        │
        ▼
  (children components render normally, using Sidebar layout)

Key points:
Parent passes props: <AppSidebar color="blue" collapsed={true} />
AppSidebar collects props: { ...props }
Props are forwarded: <Sidebar {...props}>
Sidebar receives props and can use them internally for rendering behavior.
This pattern is called “prop forwarding”, and it’s very common when creating wrapper components in React.

// AppSidebar wrapper
function AppSidebar({ ...props }) {
  return (
    <Sidebar {...props}>
      <SidebarHeader>
        <div>Header</div>
      </SidebarHeader>
      <SidebarContent>
        <div>Content</div>
      </SidebarContent>
      <SidebarFooter>
        <div>Footer</div>
      </SidebarFooter>
    </Sidebar>
  )
}

// Using the component
<AppSidebar color="lightblue" collapsed={true} />

AppSidebar receives props { color: "lightblue", collapsed: true }
AppSidebar forwards them to Sidebar via {...props}
Sidebar uses those props:
color="lightblue" → sidebar background becomes light blue
collapsed={true} → sidebar renders in a minimized/collapsed style

Expanded Sidebar (collapsed=false)
+------------------------+
| Header                 |
+------------------------+
| Content                |
| Thread List etc.       |
+------------------------+
| Footer                 |
+------------------------+

Collapsed Sidebar (collapsed=true)
+-----+
| H   |
+-----+
| C   |
+-----+
| F   |
+-----+

Here, only icons might show, text hidden, because collapsed=true

9.Next.js - Layout  [Next.js 13+ App Router layout file written in TypeScript. It controls the global structure and styling of your app. Here’s exactly what each part does:]
export const metadata: Metadata = {
  title: "assistant-ui Starter App",
  description: "Generated by create-assistant-ui",
};
RootLayout Component
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
RootLayout is a special Next.js layout component that wraps all pages.

children represents all nested page content inside this layout.

<html lang="en"> sets the language attribute.

<body className=...> applies the Google Fonts CSS variables and antialiasing for smoother text:
className={`${geistSans.variable} ${geistMono.variable} antialiased`}
This injects the fonts into the document globally.
You can now use these fonts in your CSS like:

Summary of What This Does

Loads two Google Fonts (Geist Sans and Geist Mono) as CSS variables.
Applies global styles from globals.css.
Sets default metadata (title, description).
Wraps your entire app in <html> and <body> with fonts and antialiasing applied.
Acts as the root layout for all pages in your Next.js app
Sets default HTML <title> and <meta> description for the site.
Used by Next.js to inject SEO-friendly metadata automatically.

RootLayout
│
├─ <html lang="en">
│   │
│   └─ <body class="{geistSans} {geistMono} antialiased">
│       │
│       └─ {children}  → This is where your page content goes
│           ├─ Page1
│           ├─ Page2
│           └─ etc.

Explanation:

RootLayout
The outermost wrapper for all pages.
Only one per app (usually in app/layout.tsx).
<html lang="en">
Sets the language for the whole document.
<body class="...">
Applies global fonts and antialiasing.
geistSans → variable --font-geist-sans
geistMono → variable --font-geist-mono
antialiased → makes fonts smoother.
{children}
Represents all nested page content (your page.tsx files, components, etc.).
Everything inside your pages will inherit the <body> styles and fonts.


Font Usage in CSS
After this layout, you can use the fonts globally like:
This way, normal text uses Geist Sans and code blocks use Geist Mono.
body {
  font-family: var(--font-geist-sans);
}

code, pre {
  font-family: var(--font-geist-mono);
}

RootLayout
│
├─ <html lang="en">
│   │
│   └─ <body class="geistSans geistMono antialiased">
│       │
│       ├─ Header
│       │    └─ Uses Geist Sans (default)
│       │
│       ├─ Main Content
│       │    ├─ Paragraphs → Geist Sans
│       │    └─ Code blocks / <pre><code> → Geist Mono
│       │
│       └─ Footer
│            └─ Uses Geist Sans

How It Works in Practice
Geist Sans (--font-geist-sans) → applied to body text like headers, paragraphs, nav links.
Geist Mono (--font-geist-mono) → applied to code elements (code, pre) via CSS.
Antialiased → all text is smoother on screens
The RootLayout wraps everything.
Fonts are loaded globally but can be applied selectively with CSS variables.
Pages and components inherit these styles automatically.

This doesn’t automatically apply the font to any element. Instead:
geistSans.variable → creates a CSS custom property --font-geist-sans holding the font family.

geistMono.variable → creates --font-geist-mono.

By adding them to <body>:
<body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
You now have these CSS variables available globally in your CSS.

Using the CSS variables selectively
You can now target specific elements with these fonts
/* Apply Geist Sans to all body text */
body {
  font-family: var(--font-geist-sans);
}

/* Apply Geist Mono only to code blocks */
code, pre {
  font-family: var(--font-geist-mono);
}

/* Apply Geist Sans to headings, but Mono to special spans */
h1, h2, h3 {
  font-family: var(--font-geist-sans);
}

.special-code {
  font-family: var(--font-geist-mono);
}
var(--font-geist-sans) → uses Geist Sans only where you explicitly reference it.
var(--font-geist-mono) → uses Geist Mono only where needed.
You could mix them in the same page depending on the element.

Why this is “selective”
Even though both font variables are available globally, you decide which element uses which font. Example:
<p>This is normal text.</p>
<code>const x = 10;</code>
<span class="special-code">Special code snippet</span>
<p> → Geist Sans
<code> → Geist Mono
<span class="special-code"> → Geist Mono
No extra wrappers are needed because the variables are already available on <body>.


4. Bonus: Combining with Tailwind or utility classes
If you use Tailwind, you can also create a font class:
// In globals.css
.font-sans { font-family: var(--font-geist-sans); }
.font-mono { font-family: var(--font-geist-mono); }

<p className="font-sans">Hello World</p>
<code className="font-mono">const x = 10;</code>

6.Next.Js [Layout & Page]
layout.tsx and page.tsx
Is central to how the routing and UI structure works. Let me break it down carefully and clearly.
app/
├── layout.tsx
├── page.tsx
├── dashboard/
│   ├── layout.tsx
│   └── page.tsx
layout.tsx – Defines the layout for a segment of your app (can include headers, footers, navbars, etc.).
page.tsx – Defines the actual content of a route (the page content).
Each folder in app/ can have a layout.tsx.
A layout wraps all pages and nested layouts inside that folder.
Layouts are persistent: navigating between pages in the same layout doesn’t unmount the layout, which is great for things like keeping a sidebar state.

// app/layout.tsx
import './globals.css';
import { ReactNode } from 'react';

export default function RootLayout({ children }: { children: ReactNode }) {
  return (
    <html lang="en">
      <body>
        <header>My Site Header</header>
        <main>{children}</main>
        <footer>My Site Footer</footer>
      </body>
    </html>
  );
}

How page.tsx works
page.tsx is rendered inside the nearest layout.
children from the layout is replaced by the page content.
app/page.tsx
export default function HomePage() {
  return (
    <div>
      <h1>Welcome to My Home Page</h1>
      <p>This is the main content.</p>
    </div>
  );
}

When you visit /:
RootLayout wraps around HomePage.
The rendered HTML is essentially:
<html>
  <body>
    <header>My Site Header</header>
    <main>
      <div>
        <h1>Welcome to My Home Page</h1>
        <p>This is the main content.</p>
      </div>
    </main>
    <footer>My Site Footer</footer>
  </body>
</html>

4. Nested Layouts
If you add a folder with its own layout, it overrides the parent layout only inside that folder.
Example: app/dashboard/layout.tsx
export default function DashboardLayout({ children }: { children: React.ReactNode }) {
  return (
    <div style={{ display: 'flex' }}>
      <aside>Sidebar</aside>
      <main>{children}</main>
    </div>
  );
}

Example: app/dashboard/page.tsx
export default function DashboardPage() {
  return <h1>Dashboard Content</h1>;
}
When you visit /dashboard:
RootLayout wraps the page with <html> and <body> etc.
DashboardLayout wraps the page content specifically for /dashboard.
Final rendering:
<html>
  <body>
    <header>My Site Header</header>
    <div style="display:flex;">
      <aside>Sidebar</aside>
      <main>
        <h1>Dashboard Content</h1>
      </main>
    </div>
    <footer>My Site Footer</footer>
  </body>
</html>

5. Key Points
Every page.tsx must be inside a folder with a layout, directly or inherited.
children in layout.tsx is where the page content appears.
Layouts are persistent across nested routes, which improves performance and UX.
You can nest multiple layouts for complex apps.

6. RootLayout
 ├─ Global Navbar
 ├─ DashboardLayout
 │    ├─ Sidebar
 │    └─ SettingsLayout
 │         └─ SettingsPage
 └─ Global Footer
Layouts stack automatically based on directory nesting.
children represents the inner content.
Useful for different shells (dashboard sidebar, auth layout, etc).
You can also use parallel layouts and slotting (advanced patterns).
Would you like me to also show you how TypeScript typing can be improved with PropsWithChildren or do you prefer keeping it simple with { children: ReactNode }

7. NavBar 
In a Next.js / React app, a NavBar (Navigation Bar) is just a reusable UI component that contains links to different pages of your app.
It’s usually placed in a layout so that it appears consistently across multiple pages (like the top navigation in most websites).

Example: Simple NavBar Component
// components/NavBar.tsx
"use client"; // needed if using hooks like usePathname, useRouter

import Link from "next/link";
import { usePathname } from "next/navigation";

export default function NavBar() {
  const pathname = usePathname(); // get current route

  return (
    <nav style={{ display: "flex", gap: "1rem", padding: "1rem", background: "#ddd" }}>
      <Link href="/" style={{ fontWeight: pathname === "/" ? "bold" : "normal" }}>
        Home
      </Link>
      <Link href="/dashboard" style={{ fontWeight: pathname.startsWith("/dashboard") ? "bold" : "normal" }}>
        Dashboard
      </Link>
      <Link href="/about" style={{ fontWeight: pathname === "/about" ? "bold" : "normal" }}>
        About
      </Link>
    </nav>
  );
}

Using NavBar in Layout
You can drop it into your root layout so it shows up everywhere:
// app/layout.tsx
import type { ReactNode } from "react";
import NavBar from "@/components/NavBar";

export default function RootLayout({ children }: { children: ReactNode }) {
  return (
    <html lang="en">
      <body>
        <NavBar /> {/* ✅ always visible at top */}
        <main>{children}</main>
      </body>
    </html>
  );
}
What it does
Provides navigation links between pages (Link from Next.js prevents full page reloads).
Can highlight the active route using usePathname().
Often styled with CSS, Tailwind, or a UI library (like Material UI or Chakra UI).
Do you want me to also show you how to build a responsive NavBar with a hamburger menu

10.BreadCrumb
A breadcrumb in web apps is a navigation aid that shows users where they are in the app hierarchy and lets them quickly go back to parent pages.

Think of it like a trail of links (like "Home → Dashboard → Settings → Profile").
It’s called "breadcrumb" after the fairy tale (Hansel & Gretel leaving breadcrumbs to find their way back).
Why use breadcrumbs?
Improves navigation in apps with deep nested pages.
Helps with orientation — users always know their current location.
Boosts SEO (search engines use it to understand site structure).
Example: Breadcrumb Component (Next.js + TypeScript)
// components/Breadcrumb.tsx
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";

export default function Breadcrumb() {
  const pathname = usePathname();
  const segments = pathname.split("/").filter(Boolean); // ["dashboard", "settings"]

  return (
    <nav style={{ margin: "1rem 0", fontSize: "14px" }}>
      <Link href="/">Home</Link>
      {segments.map((segment, index) => {
        const href = "/" + segments.slice(0, index + 1).join("/");
        const isLast = index === segments.length - 1;

        return (
          <span key={href}>
            {" → "}
            {isLast ? (
              <span style={{ fontWeight: "bold" }}>{segment}</span>
            ) : (
              <Link href={href}>{segment}</Link>
            )}
          </span>
        );
      })}
    </nav>
  );
}

How it works
If you’re on:
/dashboard/settings/profile
It will render:
1. Create a breadcrumb component (Breadcrumb.tsx):
"use client"; // for Next.js 13+ (app router)
import Link from "next/link";
import { usePathname } from "next/navigation";

export default function Breadcrumb() {
  const pathname = usePathname();

  // Split the path into segments
  const segments = pathname.split("/").filter(Boolean);

  return (
    <nav aria-label="breadcrumb">
      <ol className="flex gap-2 text-gray-600">
        <li>
          <Link href="/">Home</Link>
        </li>
        {segments.map((segment, index) => {
          const href = "/" + segments.slice(0, index + 1).join("/");
          const isLast = index === segments.length - 1;

          return (
            <li key={href} className="flex items-center gap-2">
              <span>/</span>
              {isLast ? (
                <span className="font-semibold">{segment}</span>
              ) : (
                <Link href={href}>{segment}</Link>
              )}
            </li>
          );
        })}
      </ol>
    </nav>
  );
}

2. Use it in your layout or page:
import Breadcrumb from "@/components/Breadcrumb";

export default function Page() {
  return (
    <div>
      <Breadcrumb />
      <h1>Product Page</h1>
    </div>
  );
}

Notes
usePathname is from Next.js App Router (next/navigation).
In Pages Router (next/router), you’d use useRouter() instead.
You can format the labels (e.g., replace - with spaces, capitalize words).
For SEO, you might want to add schema.org structured data for breadcrumbs.


11. Client vs Server 
Yes — you can absolutely use an external API in a Next.js + React + TypeScript project. There are two common ways to do it, depending on whether you want the API call to happen on the server (Node.js environment) or on the client (browser).
1. Call the external API on the server
This is often the better approach when:
You want to keep API keys secret (not exposed to the browser).
You want to preprocess or cache data before sending it to the client.
You’re using Next.js API routes or Server Components.

Example with API Route (pages/api/... or app/api/...):
// app/api/data/route.ts (Next.js 13+ App Router with TypeScript)
import { NextResponse } from "next/server";

export async function GET() {
  const res = await fetch("https://external-api.com/data", {
    headers: {
      Authorization: `Bearer ${process.env.EXTERNAL_API_KEY}`, // safe on server
    },
  });

  const data = await res.json();
  return NextResponse.json(data);
}
Then from your client-side React component:

"use client";

import { useEffect, useState } from "react";

export default function MyComponent() {
  const [data, setData] = useState<any>(null);

  useEffect(() => {
    fetch("/api/data")
      .then((res) => res.json())
      .then(setData);
  }, []);

  return <pre>{JSON.stringify(data, null, 2)}</pre>;
}

2. Call the external API on the client
--------------------------------------
This is fine if:
The API doesn’t need authentication or uses public tokens
You don’t mind exposing the request directly from the browser.

"use client";

import { useEffect, useState } from "react";

export default function MyComponent() {
  const [data, setData] = useState<any>(null);

  useEffect(() => {
    fetch("https://external-api.com/public-endpoint")
      .then((res) => res.json())
      .then(setData);
  }, []);

  return <pre>{JSON.stringify(data, null, 2)}</pre>;
}

Best practice: If the external API requires API keys or secrets, always call it from the server side (API route, server component, or getServerSideProps).
Would you like me to show you the App Router way (Next.js 13+ with app/ directory) or the Pages Router way (pages/ directory) for your project?




