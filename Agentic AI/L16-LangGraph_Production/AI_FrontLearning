1.Modern React Hooks: Components use React hooks like useState, useEffect, and custom hooks **ThreadContext.tsx:19
2.Radix UI components for accessible UI primitives - keyboard navigation, ARIA attributes, screen reader support, focus management


3.State
4.Props = what you get (from outside).
5.State = what you manage (inside yourself).
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0); // count = state

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}

import React from "react";
import { createRoot } from "react-dom/client";
import Counter from "./Counter"; // 👈 assuming your file is Counter.js

function App() {
  return (
    <div>
      <h1>My First React App</h1>
      <Counter /> {/* 👈 This is how you "call" Counter */}
    </div>
  );
}

const root = createRoot(document.getElementById("root"));
root.render(<App />);


Prop
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}

// Using Greeting with different props
<Greeting name="Alice" />
<Greeting name="Bob" />
name is a prop.
Greeting component cannot change props.name — it only uses it.


6.Routing
npm install react-router-dom
npm install -D @types/react-router-dom
import { BrowserRouter, Routes, Route } from "react-router-dom";
import Home from "./pages/Home";
import About from "./pages/About";
import Contact from "./pages/Contact";

In your App.tsx, wrap your app with BrowserRouter and define routes:
function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/contact" element={<Contact />} />
      </Routes>
    </BrowserRouter>
  );
}
/ → Home page
/about → About page
/contact → Contact page
export default App;

Navigation Links
To move between pages, use <Link> or <NavLink> instead of <a> tags (so React doesn’t reload the page):
import { Link } from "react-router-dom";

function Navbar() {
  return (
    <nav>
      <Link to="/">Home</Link> |{" "}
      <Link to="/about">About</Link> |{" "}
      <Link to="/contact">Contact</Link>
    </nav>
  );
}

export default Navbar;

4. Programmatic Navigation
Sometimes you need to navigate after an action (e.g., form submit).
For that, use the useNavigate hook:
import { useNavigate } from "react-router-dom";

function Contact() {
  const navigate = useNavigate();

  const handleSubmit = () => {
    // after submitting, go to Home
    navigate("/");
  };

  return (
    <div>
      <h2>Contact Page</h2>
      <button onClick={handleSubmit}>Go Home</button>
    </div>
  );
}

export default Contact;

5. Dynamic Routes (with Params)
You can define routes with parameters:
<Route path="/users/:id" element={<UserProfile />} />
Inside UserProfile.tsx:
import { useParams } from "react-router-dom";

function UserProfile() {
  const { id } = useParams<{ id: string }>();
  return <h2>User Profile for ID: {id}</h2>;
}

7. SideBar 
+--------------------------------+
| SidebarHeader                  |
| +----------------------------+ |
| | SidebarMenu                | |
| | +------------------------+ | |
| | | SidebarMenuItem        | | |
| | | +--------------------+ | | |
| | | | SidebarMenuButton   | | | |
| | | | +----------------+ | | | |
| | | | | Link           | | | | |
| | | | | +------------+ | | | | |
| | | | | | Icon       | | | | | |
| | | | | | MessagesSquare   | | |
| | | | | +------------+ | | | | |
| | | | | | Text       | | | | | |
| | | | | | "assistant-ui" | | | |
| | | | +----------------+ | | | |
| | | +--------------------+ | | |
| | +------------------------+ | |
| +----------------------------+ |
+--------------------------------+
| SidebarContent                 |
| +----------------------------+ |
| | ThreadList                 | |
| +----------------------------+ |
+--------------------------------+
| SidebarRail                    |
| (Optional slim navigation)     |
+--------------------------------+
| SidebarFooter                  |
| +----------------------------+ |
| | SidebarMenu                | |
| | +------------------------+ | |
| | | SidebarMenuItem        | | |
| | | +--------------------+ | | |
| | | | SidebarMenuButton   | | | |
| | | | +----------------+ | | | |
| | | | | Link           | | | | |
| | | | | +------------+ | | | | |
| | | | | | Icon       | | | | | |
| | | | | | Github     | | | | | |
| | | | | +------------+ | | | | |
| | | | | | Text       | | | | | |
| | | | | | "GitHub"   | | | | | |
| | | | | | "View Source" | | | |
| | | | +----------------+ | | | |
| | | +--------------------+ | | |
| | +------------------------+ | |
+--------------------------------+
Header is at the top, Footer at the bottom.
Content is scrollable in the middle.
SidebarRail is optional, could be a thin vertical bar on the side.
Each menu item consists of an icon and text stacked vertically.


Sidebar
│
├─ SidebarHeader
│  └─ SidebarMenu
│     └─ SidebarMenuItem
│        └─ SidebarMenuButton
│           └─ Link (https://assistant-ui.com)
│              ├─ Icon container (MessagesSquare)
│              └─ Text container
│                 └─ "assistant-ui"
│
├─ SidebarContent
│  └─ ThreadList
│
├─ SidebarRail
│  (empty in this code, acts as a rail/navigation)
│
└─ SidebarFooter
   └─ SidebarMenu
      └─ SidebarMenuItem
         └─ SidebarMenuButton
            └─ Link (https://github.com/assistant-ui/assistant-ui)
               ├─ Icon container (Github)
               └─ Text container
                  ├─ "GitHub"
                  └─ "View Source"


Props 
<AppSidebar color="blue" collapsed={true}>
        │
        │  (all props collected into `props` via ...props)
        ▼
function AppSidebar({ ...props })
        │
        │  (props are spread onto Sidebar)
        ▼
<Sidebar {...props}>
        │
        │  Sidebar receives:
        │  - color="blue"
        │  - collapsed={true}
        │
        │  Sidebar handles these props internally:
        │    ├─ SidebarHeader
        │    ├─ SidebarContent
        │    ├─ SidebarRail
        │    └─ SidebarFooter
        │
        ▼
  (children components render normally, using Sidebar layout)

Key points:
Parent passes props: <AppSidebar color="blue" collapsed={true} />
AppSidebar collects props: { ...props }
Props are forwarded: <Sidebar {...props}>
Sidebar receives props and can use them internally for rendering behavior.
This pattern is called “prop forwarding”, and it’s very common when creating wrapper components in React.

// AppSidebar wrapper
function AppSidebar({ ...props }) {
  return (
    <Sidebar {...props}>
      <SidebarHeader>
        <div>Header</div>
      </SidebarHeader>
      <SidebarContent>
        <div>Content</div>
      </SidebarContent>
      <SidebarFooter>
        <div>Footer</div>
      </SidebarFooter>
    </Sidebar>
  )
}

// Using the component
<AppSidebar color="lightblue" collapsed={true} />

AppSidebar receives props { color: "lightblue", collapsed: true }
AppSidebar forwards them to Sidebar via {...props}
Sidebar uses those props:
color="lightblue" → sidebar background becomes light blue
collapsed={true} → sidebar renders in a minimized/collapsed style

Expanded Sidebar (collapsed=false)
+------------------------+
| Header                 |
+------------------------+
| Content                |
| Thread List etc.       |
+------------------------+
| Footer                 |
+------------------------+

Collapsed Sidebar (collapsed=true)
+-----+
| H   |
+-----+
| C   |
+-----+
| F   |
+-----+

Here, only icons might show, text hidden, because collapsed=true

9.Next.js - Layout  [Next.js 13+ App Router layout file written in TypeScript. It controls the global structure and styling of your app. Here’s exactly what each part does:]
export const metadata: Metadata = {
  title: "assistant-ui Starter App",
  description: "Generated by create-assistant-ui",
};
RootLayout Component
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
RootLayout is a special Next.js layout component that wraps all pages.

children represents all nested page content inside this layout.

<html lang="en"> sets the language attribute.

<body className=...> applies the Google Fonts CSS variables and antialiasing for smoother text:
className={`${geistSans.variable} ${geistMono.variable} antialiased`}
This injects the fonts into the document globally.
You can now use these fonts in your CSS like:

Summary of What This Does

Loads two Google Fonts (Geist Sans and Geist Mono) as CSS variables.
Applies global styles from globals.css.
Sets default metadata (title, description).
Wraps your entire app in <html> and <body> with fonts and antialiasing applied.
Acts as the root layout for all pages in your Next.js app
Sets default HTML <title> and <meta> description for the site.
Used by Next.js to inject SEO-friendly metadata automatically.

RootLayout
│
├─ <html lang="en">
│   │
│   └─ <body class="{geistSans} {geistMono} antialiased">
│       │
│       └─ {children}  → This is where your page content goes
│           ├─ Page1
│           ├─ Page2
│           └─ etc.

Explanation:

RootLayout
The outermost wrapper for all pages.
Only one per app (usually in app/layout.tsx).
<html lang="en">
Sets the language for the whole document.
<body class="...">
Applies global fonts and antialiasing.
geistSans → variable --font-geist-sans
geistMono → variable --font-geist-mono
antialiased → makes fonts smoother.
{children}
Represents all nested page content (your page.tsx files, components, etc.).
Everything inside your pages will inherit the <body> styles and fonts.


Font Usage in CSS
After this layout, you can use the fonts globally like:
This way, normal text uses Geist Sans and code blocks use Geist Mono.
body {
  font-family: var(--font-geist-sans);
}

code, pre {
  font-family: var(--font-geist-mono);
}

RootLayout
│
├─ <html lang="en">
│   │
│   └─ <body class="geistSans geistMono antialiased">
│       │
│       ├─ Header
│       │    └─ Uses Geist Sans (default)
│       │
│       ├─ Main Content
│       │    ├─ Paragraphs → Geist Sans
│       │    └─ Code blocks / <pre><code> → Geist Mono
│       │
│       └─ Footer
│            └─ Uses Geist Sans

How It Works in Practice
Geist Sans (--font-geist-sans) → applied to body text like headers, paragraphs, nav links.
Geist Mono (--font-geist-mono) → applied to code elements (code, pre) via CSS.
Antialiased → all text is smoother on screens
The RootLayout wraps everything.
Fonts are loaded globally but can be applied selectively with CSS variables.
Pages and components inherit these styles automatically.

This doesn’t automatically apply the font to any element. Instead:
geistSans.variable → creates a CSS custom property --font-geist-sans holding the font family.

geistMono.variable → creates --font-geist-mono.

By adding them to <body>:
<body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
You now have these CSS variables available globally in your CSS.

Using the CSS variables selectively
You can now target specific elements with these fonts
/* Apply Geist Sans to all body text */
body {
  font-family: var(--font-geist-sans);
}

/* Apply Geist Mono only to code blocks */
code, pre {
  font-family: var(--font-geist-mono);
}

/* Apply Geist Sans to headings, but Mono to special spans */
h1, h2, h3 {
  font-family: var(--font-geist-sans);
}

.special-code {
  font-family: var(--font-geist-mono);
}
var(--font-geist-sans) → uses Geist Sans only where you explicitly reference it.
var(--font-geist-mono) → uses Geist Mono only where needed.
You could mix them in the same page depending on the element.

Why this is “selective”
Even though both font variables are available globally, you decide which element uses which font. Example:
<p>This is normal text.</p>
<code>const x = 10;</code>
<span class="special-code">Special code snippet</span>
<p> → Geist Sans
<code> → Geist Mono
<span class="special-code"> → Geist Mono
No extra wrappers are needed because the variables are already available on <body>.


4. Bonus: Combining with Tailwind or utility classes
If you use Tailwind, you can also create a font class:
// In globals.css
.font-sans { font-family: var(--font-geist-sans); }
.font-mono { font-family: var(--font-geist-mono); }

<p className="font-sans">Hello World</p>
<code className="font-mono">const x = 10;</code>
