Deep Agent [they can flexibly apply different strategies, using intermediate results to guide their exploration]
https://huggingface.co/blog/open-deep-research
https://github.com/google-gemini/gemini-fullstack-langgraph-quickstart
https://www.anthropic.com/news/research
https://openai.com/index/introducing-deep-research/
https://www.anthropic.com/engineering/multi-agent-research-system
https://www.perplexity.ai/hub/blog/introducing-perplexity-deep-research
https://gemini.google/overview/deep-research/?hl=en

Open Deep Reserach 
https://github.com/langchain-ai/open_deep_research



Ambient Agent 
https://www.youtube.com/watch?v=egSh4TxS5go
https://luma.com/aoc5opn4?tk=YZybri
https://www.meetup.com/gdgsanfrancisco/events/310139159/
https://luma.com/langchain

Multi Agent 
https://luma.com/4mzs16uv


LangChain Academy 
https://www.langchain.com/langchain-academy-live
https://blog.langchain.com/?_gl=1*if2z4v*_gcl_au*MjA1NDc4NDAxMC4xNzU1NjY0NzE3*_ga*MTAzNTE5MTAwOS4xNzU2ODEwNjE2*_ga_47WX3HKKY2*czE3NTY4MTA2MTUkbzEkZzEkdDE3NTY4MTIwMjYkajYwJGwwJGgw

LangChain Interrupts
https://interrupt.langchain.com/?utm_source=blog&utm_medium=organic&utm_campaign=earlybird&ajs_aid=8404d422-521f-4e61-9869-288d6b04d11d&ajs_uid=0fd5b795-fed4-4767-b5e7-41a293c59103&_gl=1*depneb*_gcl_au*MjA1NDc4NDAxMC4xNzU1NjY0NzE3*_ga*MTAzNTE5MTAwOS4xNzU2ODEwNjE2*_ga_47WX3HKKY2*czE3NTY4MTA2MTUkbzEkZzEkdDE3NTY4MTIwODUkajEkbDAkaDA.

Very Important Recordings
https://interrupt.langchain.com/video

Deep Agent
----------
Build your own deep research agent to handle research tasks.
Learn how to use LangGraph to build a multi-agent system.
Use LangSmith to evaluate its performance.

Agenda
Research Agent
Research Agent with MCP 
Research Supervisor 
Multi-Agent Research System 

User -- Reuqest -->
                           Scope --- Brief --> Research -- Findings --> Write --> Report
     <-- Clarification --

1.Multi Agent Architecture 
2.Prompting Techniques [like adding thinking steps that improve performance]
3.Built in persistence layer is great for tracking the progress of multiple agents that are recording results from the research over a 
  long time period. 
4.LangSmith for observability and evaluation, giving you detailed visibility into our long-running agent.
5.LangSmith also lets you test and monitor components of the agents as you develop and deploy them 
6.Supervisor agent to manage multiple research agents. 




Produce comprehensive reports using various sources of context

Research itself is a great use case for agents. 
Since Topic & Source aren't known ahead of time. the application requires a high level of agency and decision making 

1.Research is an open-ended task; the best strategy to answer a user request can’t be easily known in advance
2.Requests can require different research strategies and varying levels of search depth.
3.Open deep research uses an agent to conduct research as part of a three step process:

Scope – clarify research scope
Research – perform research
Write – produce the final report

1. User Clarification and Brief Generation 
Purpose: Clarify research scope and transform user input into structured research briefs
User Clarification: Determines if additional context is needed from the user using structured output
Brief Generation: Transforms conversations into detailed research questions
LangGraph Commands: Using Command system for flow control and state updates
Structured Output: Pydantic schemas for reliable decision making
**What You'll Learn: State management, structured output patterns, conditional routing

2. Research Agent with Custom Tools
Purpose: Build an iterative research agent using external search tools
Agent Architecture: LLM decision node + tool execution node pattern
Sequential Tool Execution: Reliable synchronous tool execution
Search Integration: Tavily search with content summarization
Tool Execution: ReAct-style agent loop with tool calling
**Content summarization to compress search results
**Iterative research loop with conditional routing
**Rich prompt engineering for comprehensive research

**What You'll Learn: Agent patterns, tool integration, search optimization, research workflow design

3. Research Agent with MCP (notebooks/3_research_agent_mcp.ipynb)
Purpose: Integrate Model Context Protocol (MCP) servers as research tools
Model Context Protocol: Standardized protocol for AI tool access
MCP Architecture: Client-server communication via stdio/HTTP
LangChain MCP Adapters: Seamless integration of MCP servers as LangChain tools
Local vs Remote MCP: Understanding transport mechanisms

MultiServerMCPClient for managing MCP servers
Configuration-driven server setup (filesystem example)
Rich formatting for tool output display
Async tool execution required by MCP protocol (no nested event loops needed)

**What You'll Learn: MCP integration, client-server architecture, protocol-based tool access

4. Research Supervisor
Purpose: Multi-agent coordination for complex research tasks
Supervisor Pattern: Coordination agent + worker agents
Parallel Research: Concurrent research agents for independent topics using parallel tool calls
Research Delegation: Structured tools for task assignment
Context Isolation: Separate context windows for different research topics

**Two-node supervisor pattern (supervisor + supervisor_tools)
Parallel research execution using asyncio.gather() for true concurrency
Structured tools (ConductResearch, ResearchComplete) for delegation
Enhanced prompts with parallel research instructions
Comprehensive documentation of research aggregation patterns

**What You'll Learn: Multi-agent patterns, parallel processing, research coordination, async orchestration

5. Full Multi-Agent Research System
Purpose: Complete end-to-end research system integrating all components
Three-Phase Architecture: Scope → Research → Write
System Integration: Combining scoping, multi-agent research, and report generation
State Management: Complex state flow across subgraphs
End-to-End Workflow: From user input to final research report

Complete workflow integration with proper state transitions
Supervisor and researcher subgraphs with output schemas
Final report generation with research synthesis
Thread-based conversation management for clarification

**What You'll Learn: System architecture, subgraph composition, end-to-end workflows

Key Learning Outcomes

Structured Output: Using Pydantic schemas for reliable AI decision making
Async Orchestration: Strategic use of async patterns for parallel coordination vs synchronous simplicity
Agent Patterns: ReAct loops, supervisor patterns, multi-agent coordination
Search Integration: External APIs, MCP servers, content processing
Workflow Design: LangGraph patterns for complex multi-step processes
State Management: Complex state flows across subgraphs and nodes
Protocol Integration: MCP servers and tool ecosystems




Deep Agent - Planning Agent 
--------------------------
Complex 
Long Running 
Operate Complex Task over long time horizon
sophisticated agent architecture capable of handling real-world research and analysis tasks.

https://github.com/langchain-ai/deep-agents-from-scratch
https://github.com/langchain-ai/deepagents
https://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus

Task planning (e.g., todo), often with recitation
Context offloading to file systems
Context isolation through sub-agent delegation

Planning 
File System 
Sub Agents 
Prompting 

Put all this things into agent with the custom tools 
Plan 
Offload Context 
Sub-Agent 

Planning 
1. Use the Scheduling tools to keep track of what i need to do when, while, 
2. Planning tool to keep track what they need to do. 
3.Planning: TODO Lists
4.files is a virtual file system contained in state which you will explore in the next lesson.




1.Create Agent 
2.Todo Lists    
3.Files 
4.SubAgents



Manus Agent 
1. TODO list writes in the md file , and then reads by the agent. and loads into the context to steer the agent. 
2. read back iteratively and update it over the time. 



key Points
1. LLM Agent can interact with all our computing infrastructure. 
2. Anthropic Claude Code is a long Running Agent. and OpenAI's Deep Research 
3. Agent Will lose their way over long sequences. 
4. Manus Agent can do more tool calls 
5. Claude Anthropic can do more turn of conversation spanning hundreds of turns. 
6. Offloading the context is very important, and then reads on demand
7. File System also useful to offload the token heavy tool call 
8. Offloading the context is very important, and then reads on demand, update over time, compare the final answer whether it is grounded 
it with the plan, asking for approval. 
9. Use Files for long term memory - Ambient Agent. 
10. Offload the token heavy tool call context, and save the summary in the agent message.
     then can assess if full context required of particular tool call. for agent's trajectory. 
11. File System is serves as external memory. [perpetuity - the state or quality of lasting forever:]
12. Sub-Agents for Context Isolation
13. Sub-Agents have Lower Risk - They make Implicit and sometimes conflicting decisions. 
       Walden Yan - Congition. 
    Issue can be fix if subagents are work parallelizable. 
For Example: Open DeepResearch - uses subagents only for research and collect the conext, and only one time report will generate 
14. Often much of the steering is pushed by agent system prompt itself. 
15. Very Thoughtful prompting really what charaterizes many of these long running agents. 
16.files is a virtual file system contained in state which you will explore in the next lesson.
17.The challenge with TODO lists lies in maintaining attention as context windows grow—the average Manus task uses approximately 50 tool calls, creating substantial risk of context rot.



All uses subagents for delegation of tasks 
Claude Code
Anthropic Multi Agent Research
Open Deep Research 
Google Deep Research 
Manus Agent - has Sub Agents


Deep Agent Abstraction 
-----------------------
To build different agents from this abstraction 


Reconcile 
1. Files Upload - node one 
2. Validate if it matches with the column or not - node two otherwise route to the user. 
         Conditional edge to end or continue or route to user for clarification
3.

Tool with LangGraph State
Access and Modify 
Access and modify state within tools
You can use this to store information to share between nodes, to debug the graph, and to reset a long-running graph to an earlier time.
When you define state for a graph, you define the data types and a 'reducer' function.  
**Reducer Function 
The reducer describes how information is added to that element.
This is especially useful when a task is mapped to multiple nodes, which are executed in parallel and update state simultaneously.

Reference - ReactAgent
https://reference.langchain.com/python/langgraph/agents/#langgraph.prebuilt.chat_agent_executor.create_react_agent
https://docs.langchain.com/oss/python/langchain/agents#what-is-an-agent

Chat Agent Executor - Implementation
https://github.com/langchain-ai/langgraph/blob/c37c9cbab3287f0988fabe2b853569a23960e3db/libs/prebuilt/langgraph/prebuilt/chat_agent_executor.py
https://github.com/langchain-ai/langgraph/blob/e365b2b8bd695e03d758b19ff109152b2e342a87/libs/prebuilt/langgraph/prebuilt/tool_node.py#L239-L293

https://reference.langchain.com/python/langgraph/agents/#langgraph.prebuilt.chat_agent_executor


https://www.anthropic.com/engineering/claude-code-best-practices - Claude Code Agents Best Practices 














 

