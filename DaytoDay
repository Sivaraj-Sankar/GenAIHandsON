July 2025

Index
Top Reasearcher 
Evals and Benchmarks - LLM
RAG Evaluation 
Evaluating LLM-Based Agents
State Management in Backend
Authentication Methods
Session-Based Authentication 
Query Param 
MongoDB - Key  
FrontEnd Interview Preparation 
UML
Figma
LLM Orchestration 





Top Reasearcher 
---------------
Trapit Bansal - RL CoT - o-series model at openAI
Shuchao Bi - co-creater of GPT-4o voice mode and o4-mini 
             Multi-modal Post-Training at OpenAI 
Huiwen Chang - co-creator of GPT-4o's image generation, 
             - MaskGIT and Muse text-to-image architectures at Google Research 
Ji Lin - o3/o4-mini, GPT-4o, GPT-4.1, GPT-4.5, 4o-imagegen and Operator Reasoning stack 
Joel Pobar - Inference at Anthropic. 
Jack Rae - pre-training tech lead for Gemini and reasoning for Gemini 2.5. Led Gopher and chinchilla early 
           LLM efforts at Deepmind
Hongyu Ren - Co-Creator of GPT-4o, 4o-mini, o1-mini o3-mini, o3 and o4-mini. Previously leading a group for post-training of OpenAI 
Johan Schalkwyk - former Google Fellow, 
Pei Sun - post-Training, coding, and reasoning of Gemini at Google Deepmind
          Waymo's Perception models 
Jiahui Yu - co-creator of o3, o4-mini, GPT-4.1 and GPT-4o. Previously led the perception team at OpenAI, and co-led multimodal at Gemini
Shengjia Zhao - ChatGPT, GPT-4, all mini models, 4.1 and o3. Previously synthetic data at openAI
Alexandr Wang: Chief AI Officer Meta - Scale AI Company

Evals and Benchmarks - LLM
--------------------
Benchmarks - Standardized tests / Evaluation suites used to measure and compare the performance of different models
             across a variety of tasks.
 - These Benchmarks help researchers, developers, and users understand how well an LLM performs in specific areas 
 - Reasoning - Comprehension - Coding - Translation - Safety 

Common Benchmarks
MMLU
HELLASWAG
ARC
GSM8K 
BIG-Bench (BBH) 


Evaluation Metrics - NLP Evaluation
-----------------------------------
The model's prediction is compared to the labeled ground truth 
Metrics like Accuracy, BLEU, F1, pass@k, ROUGE etc are used depending on the task 

Classification        - Accuracy, F1      
QA (Short answer)     - Exact Match (EM), F1
Translation           - BLEU, METEOR 
Code Generation       - pass@k, correctness 
Summarization         - ROUGE, BLEU 
Math (GSM8K)          - Exact answer matching 

RAG Evaluation 
--------------
Evaluate Retrieval Quality - Are you retrieving the right context documents
Recall@k    - % of times the correct doc is in top-k 
Precision@k - % of top-k docs that are relevant 
MMR - Mean Reciprocal Rank 
nDCG - Ranking Quality of relevant documents

def recall_at_k(retrieved_docs,relevant_docs,k=5):
  hits = sum([1 for doc in retrieved_docs[:k] if doc in relevant_docs])
  return hits / min(k,len(relevant_docs))

Evaluate Generation Quality - Is the final answer accurate, complete or grounded 
Exact Match - Text match with groun-truth answer 
ROUGE/BLEU  - Token overlap (for summaries/QA) 
Faithfulness/Groundedness - Is the answer supported by retrieved docs
F1 Score - Partial Match (word overlap, e.g. for QA) 
Human Eval - Best for complex answers (correct, useful) 

def exact_match(pred, label):
  return pred.strip().lower() == label.strip().lower()

Evaluate Faithfulness / Hallunciation - Specific to RAG
Is the Answer based only on retrieved documents, or is it hallucinating 
Attribution/Grounding Tests : Does Every fact appear in the source 
RAGAS (Hugging Face): End-to-End RAG Evaluation Tool 

from ragas.evaluation import evaluate 
from ragas.metrics import faithfulness, answer_relevancy
results = evaluate(questions=questions,contexts=contexts,answers=answers,metrics=[faithfulness,answer_relevancy],)
print(results)

Pipeline for RAG - Evaluation 
  {"query":
  "retrieved_docs":
  "generated_answer":
  gold_answer":
}
you can evaluate 
Retrieval: Does Retrieved_docs include the sentence about Paris ?
Generation: Does generated_answer match gold_answer
Grounding: Is "Paris" found in retrieved_docs ?


Retrieval - FAISS BM25 ColBERT
Generation -  GPT, T5, LLaMA, etc 
Evaluation - RAGS, Llamaindex Evals, Trulens, Langchain evals 

Building a Test set for RAG evaluation 
Implementing custom metrics 
Comparing two RAG versions (e.g. BM25 vs embedding retriever) 

Evaluating LLM-Based Agents 
---------------------------

Evaluating AI Agents 
Agent Capabilities Evaluation - Planing and Multi-Step Reasoning  - AQUA-RAT
                                Function Calling - Tool Use 
                                Self-Reflection 
                                Memory 
                          
Application-Specific Agent Evaluation - 
Generalist Agents Evaluation 
Frameworks for Agent Evaluation 


Agentic AI's Web Search and Reasoning capabilities involves a multi-dimensional approach. 
- Compile a dataset of queries that cover
  Typical Searches 
  Edge Cases - vague, ambiguous or trick questions
  Multi-Step Tasks - requiring search + synthesis 

Quantitative Metrics 
Apply both Information Retrieval (IR) and agenti-specific metrics
IR Metrics 
* Precision@k, Recall, nDCG - measure relevance and ranking quality 
* Session success rate/ CTR - track how often user clicks or engages meaninfully 

Agentic AI Metrics (from Galileo's taxonomy) 
System Metrics: Latency, token usage, cost per task 
Task Success: Percentage of tasks completed correctly
Quality - instruction adherence, output format, factual accuracy
Tool Interaction - correct tool selection and parameter usage 

Tool-call accuracy - Did it choose and use the search tool appropriately 
Plan-Exectuion - Where intermediate steps logical and necessary ? Logging Traces/ 

Benchmark with known Evaluations
Designed for web-browsing agents
WebGames, BEARCUBS - simulate realistic browsing and retrieval scenarios 
InfoDeepSeek - evaluates retrieval + generation quality 


Drift in Tool Usage 
Retrieval quality 

Compare different versions v1 and v2 using statistical significance tests to validate improvements

State Management in Backend  - Like Flask & Django & FastAPI
---------------------------
State Management in the backend refers to how a web application tracks and manages data across different user interactions, sessions, or requests. 
Since HTTP is stateless by default (each request is independent and doesn't retain memory of previous interactions), backend frameworks like FastAPI, Flask, and Django need to explicitly implement ways to maintain state across requests

State Type	Description
Session State	Keeps user-specific data (e.g. login info) across requests.
Application State	Data shared across all users during the lifetime of the app (e.g. cache).
Request State	Temporary data for a single HTTP request.
Database State	Persistent data stored in a DB and retrieved as needed.

State Management in FastAPI, Flask, Django
1. Request State
Handled automatically. Each request has its own context.
Flask: via request object from flask package
FastAPI: via dependency injection (request passed into endpoint)
Django: via request object in view functions

from fastapi import Request

@app.get("/")
def read_root(request: Request):
    client_host = request.client.host
    return {"client": client_host}


2. Session State (User-specific data)
Flask: Has a built-in session object backed by cookies (signed with secret key).
FastAPI: No built-in session support, but can be added using middleware or third-party packages like starlette.middleware.sessions.
Django: Built-in session middleware with support for DB, cache, or file-based sessions.


from flask import session

@app.route('/login')
def login():
    session['user'] = 'sivaraj'
    return 'Logged in'

from starlette.middleware.sessions import SessionMiddleware

app.add_middleware(SessionMiddleware, secret_key='your-secret')

@app.get("/set-session")
def set_session(request: Request):
    request.session["user"] = "sivaraj"
    return {"message": "session set"}


3. Application State
Shared across all requests and users.
Flask: Use app.config or global variables (not recommended for complex apps).
FastAPI: Use app.state for app-level storage.
Django: Usually uses caching or settings module for shared state.


@app.on_event("startup")
def startup_event():
    app.state.model = load_your_model()

@app.get("/predict")
def predict():
    model = app.state.model
    return model.predict(...)

4. Persistent State (Database)
State stored in a database is the most reliable way to manage long-term state across users and sessions.
Django uses ORM (models.py) and handles state via database.
Flask and FastAPI typically use SQLAlchemy, Tortoise ORM, Beanie (MongoDB), etc

Additional Considerations
Authentication/Authorization: Uses session, JWT, or OAuth to manage state.
Caching: Redis or Memcached can store temporary shared or user-specific state.
WebSocket State: Use connection state in memory or Redis for real-time apps.

Framework	Session Support	Application State	ORM/DB Integration
Flask	Built-in (session)	g, app.config	SQLAlchemy, etc.
FastAPI	Via Middleware	app.state	SQLAlchemy, Tortoise, Beanie
Django	Built-in Middleware	Django settings/cache	Django ORM


Authentication/Authorization in Backend (State Management Perspective) 
Since HTTP is stateless, we need to use mechanisms like sessions, JWT, or OAuth tokens to maintain user-specific data (i.e., state) across multiple requests after the user logs in

Authentication	Verifying who the user is (e.g., username/password).
Authorization	Verifying what the user is allowed to do (e.g., access certain APIs).

Once a user logs in (authenticates), we need a way to remember who they are on every subsequent request.
That’s where state comes in — by using Session, JWT, or OAuth mechanisms

1. Session-based Authentication (Server-Side State)
Stores user login info in memory or database on the server.
Sends a session ID to the client as a cookie.
On each request, the client sends the session ID; the server looks up the user.

Django Example 
# Login view in Django
def login_view(request):
    if request.method == "POST":
        user = authenticate(username="sivaraj", password="pass")
        if user:
            login(request, user)  # Django stores session

Server-side state:
Stored in DB or cache (Redis).
Requires server memory or infrastructure to maintain sessions.
More secure but harder to scale horizontally.

2. JWT (JSON Web Token) - (Stateless Authentication)
Once user logs in, the server issues a signed token.
This token contains user info, expiry, and is self-contained.
On every request, the client sends the token (usually in the Authorization header).

from fastapi import Depends, HTTPException
from fastapi.security import OAuth2PasswordBearer
import jwt

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        user = payload.get("sub")  # user identifier
        return user
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")

Client-side state:
Stored in the browser or app (e.g., localStorage or memory).
Scales easily (stateless).
Needs good security practice (e.g., token rotation, short expiry).

Client-side state:
Stored in the browser or app (e.g., localStorage or memory).
Scales easily (stateless).
Needs good security practice (e.g., token rotation, short expiry).

3. OAuth2 / OpenID Connect (Third-party Authentication)
Used to delegate authentication to another provider like Google, GitHub, Facebook.
Users login via a third-party.
You get a token (like JWT or an access token).
You use that token to access APIs.

Used in: Social login, enterprise apps, microservices
Example flow:
User clicks "Login with Google"
Redirected to Google, they log in
Redirected back to your app with authorization code
Your app exchanges code for access token
You can now access user data or validate session

Method	Where is State Stored?	Stateless?	Notes
Session	On the server (DB, memory, Redis)	❌ No	Easy to manage but hard to scale horizontally
JWT	In the token (client-side)	✅ Yes	Fast and scalable; no need to store anything on server
OAuth2	On client + third-party auth server	✅ Mostly	You trust another system to manage auth and token


I can provide:

Session-based login for Django/Flask
JWT login with FastAPI
OAuth login using Google
Let me know your use case (e.g., REST API with JWT for React frontend), and I’ll give you full code for that.


Login Method
-------------
POST /login
Content-Type: application/json

{
  "username": "sivaraj",
  "password": "your_password"
}


200 OK
Content-Type: application/json

{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJzaXZhcmFqIiwibmJmIjoxNzI5MDY5NDIwLCJleHAiOjE3MjkwNzMwMjB9.uCdpDShc4PQfGm5GL7FYuPC7KnFgPMql0yz1LBKTt20",
  "token_type": "bearer"
}

The token is signed with a secret key and may include:
sub: subject (user ID or username)
exp: expiration time
nbf: not before time
any custom claims (roles, scopes, etc.)


3. Client Stores the JWT
Client stores the token in memory or browser storage:
Browser: localStorage, sessionStorage
React/Frontend App: Redux store or local variable


GET /user/profile
Authorization: Bearer <JWT_TOKEN_HERE>

Decodes the token using the secret key.
Verifies exp, nbf, and sub.
If valid, returns data; else returns 401 Unauthorized


200 OK
Content-Type: application/json

{
  "username": "sivaraj",
  "email": "sivaraj@example.com",
  "role": "admin"
}



Authentication Methods 
----------------------
Auth Method	Where State is Stored	Stateless?	Suitable For	Pros	Cons
Session-Based	Server (DB, Redis, memory)	❌ No	Traditional web apps (Django, Flask), server-rendered UIs	Easy to implement, built-in CSRF protection	Not scalable across multiple servers without shared session
JWT (Token)	Client (token in header)	✅ Yes	SPAs (React/Vue), mobile apps, APIs, microservices	Scales easily, no server-side state	No built-in logout, token revocation is hard
OAuth2 / OIDC	Client + 3rd-party provider	✅ Mostly	Login via Google, GitHub, Facebook, enterprise SSO	Delegated auth, secure, standard for large systems	Complex to implement, requires trust in provider
API Key	Client (key in header)	✅ Yes	Internal services, server-to-server communication	Simple, fast	No user context, poor granularity, hard to rotate securely
Basic Auth	Client (username:password)	✅ Yes	Quick prototyping, scripts	Extremely simple	Insecure (no hashing), credentials sent on every request


Basic Authentication
How it works: Username and password encoded in Base64 and sent in each request.
Use when:
Quick development or testing scripts.
Internal systems without sensitive data.
Not recommended for production without HTTPS.

 API Key Authentication
How it works: A unique key is provided per client; key is passed in the header of every API call.
Use when:
It's a backend-to-backend system.
You don't need user-specific data, just service-level access.
Example: A backend service pulling weather data using an API key.


3. OAuth2 / OpenID Connect
How it works: Uses authorization servers (like Google) to authenticate and provide access tokens.
Use when:
You want SSO (Single Sign-On).
You want to allow users to log in using existing identities (Google, Microsoft).
You’re building enterprise or third-party integration apps.
Example: "Login with Google" on a SaaS product.

 JWT (JSON Web Token)
How it works: Server returns signed token (JWT) on login; client stores it and sends in Authorization header.
Use when:
You're building SPAs with React, Angular, or Vue.
You need stateless and scalable APIs.
You have mobile apps or microservices architecture.
Example: React + FastAPI frontend/backend combo with mobile clients.


Session-Based Authentication
How it works: Server stores session ID after login; client stores session ID in a cookie.
Use when:
You use server-rendered pages (like in Django or Flask templates).
You don’t need to scale horizontally without session stores.
Example: Classic web dashboard for internal admin system.


Session-Based Authentication
Session-Based Authentication Requires Server-Side State

In session-based authentication, the user session is stored on the server, often in:
Memory (RAM)
A local file
A database
A shared session store like Redis

So, when a user logs in:
Server generates a session ID
Server stores the session data (e.g., user info) on the server
Server sends back a cookie with session ID to the client
Client sends that cookie in each request
Server looks up the session using the session ID

Horizontal Scaling = Multiple Servers
Horizontal scaling means adding more servers or instances (e.g., in a load-balanced setup) to handle more traffic.
                 +-------------+
User → Internet →| LoadBalancer|→ Server 1
                 +-------------+→ Server 2
                                 Server 3

A user logs in, and Server 1 stores their session in its memory.
Next request goes to Server 2 (due to load balancing).
Server 2 doesn't have that session info, so the user appears logged out or gets an error.


If sessions are stored only in each server’s local memory, then:
"You can't scale horizontally"
...unless you use a shared session store (like Redis) accessible by all servers.

Solution: Session Store (Shared State)
All servers connect to Redis or Database to fetch session info.

No matter which server handles the request, it can find the session.

plaintext
Copy
Edit
Client → Load Balancer → Server 1 or Server 2
                       ↘ Redis (shared session store)



JWT Doesn’t Have This Problem
JWT is stateless
No session is stored on the server
The token carries all necessary user info
Any server can validate it using a shared secret key
So JWT is better suited for horizontal scaling, especially in cloud-native or microservice-based apps.


Concept	Session-Based	JWT-Based
Needs shared session store?	✅ Yes	❌ No
Scales easily across servers?	❌ Only with shared store	✅ Yes
Stores state on server?	✅ Yes (session data)	❌ No (client stores JWT)


Param in API 
------------
Value	How You Get It	Where It Comes From
rm_id	From JWT token	After login (attached to auth header)
application_id	From route or page context	URL param or selected application
message	From form input	RM types in message box


GET Chat History (with Path and Query Params)
GET /api/applications/abc123/chat?limit=50&sort=desc


Use Case	Parameter Type to Use	Why
Identify a specific resource	Path Param	Cleaner, more RESTful: /applications/123
Filter/sort/paginate a list	Query Param	Optional and flexible: ?sort=desc
Send structured data	Body Param (POST/PUT)	Useful for complex inputs like forms or messages
Auth, content negotiation	Header Param	Metadata like tokens or content type


Query Param 
-----------
Query parameters are part of the URL, used to send optional data like filters, pagination, search terms, etc.
They appear after the ? in the URL.
Multiple query params are joined with &

Let’s say you want to fetch chat history for an application:
// JavaScript/React/Frontend
const applicationId = 'abc123';
const limit = 20;
const sort = 'desc';

fetch(`/api/applications/${applicationId}/chat?limit=${limit}&sort=${sort}`, {
  method: 'GET',
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
});


GET /api/applications/abc123/chat?limit=20&sort=desc

app.get('/api/applications/:applicationId/chat', (req, res) => {
  const applicationId = req.params.applicationId; // from path
  const limit = req.query.limit; // from query string
  const sort = req.query.sort;

  console.log(applicationId); // "abc123"
  console.log(limit);         // "20"
  console.log(sort);          // "desc"

  // Use these values to fetch data from DB
});



def chat_view(request, application_id):
    limit = request.GET.get('limit')  # "20"
    sort = request.GET.get('sort')    # "desc"
    # application_id is from the path

    # You can use these to query the database


from fastapi import FastAPI, Query

@app.get("/api/applications/{application_id}/chat")
def get_chat(application_id: str, limit: int = Query(20), sort: str = Query("desc")):
    return {
        "application_id": application_id,
        "limit": limit,
        "sort": sort
    }


Param	Example	Used For
limit	?limit=50	Pagination
offset	?offset=10	Skip records (pagination)
sort	?sort=asc	Sort order
filter	?status=InProgress	Filter by status or keyword
search	?q=John	Search text


Always validate query params on the backend.
Provide default values in case params are missing.
Be strict with types (especially int, bool, etc.).


Frontend builds URL with ?key=value format.
Backend reads them via req.query (Express), request.GET (Django), or as function args (FastAPI).
Ideal for optional parameters like filters, sorts, and pagination.


MongoDB - Key  
------------
Note: MongoDB won’t validate that application_id: "app123" actually exists in applications. You have to enforce this in your application logic

Option	Description
Manual Checks	Validate references in code before inserting/updating
Data Embedding	Embed related data if it's read together and not huge
Two-Phase Commits	Use transactions (MongoDB 4.0+) for atomicity across collections
Mongoose (ODM)	Provides schema models and can define references


const ChatLogSchema = new mongoose.Schema({
  application_id: { type: mongoose.Schema.Types.ObjectId, ref: 'Application' },
  message: String
});


Excellent question — let's look at how PostgreSQL works with FastAPI, especially regarding primary keys, foreign keys, and validation. This is one of the biggest differences between a relational (SQL) database like PostgreSQL and a NoSQL DB like MongoDB

Yes — PostgreSQL enforces key constraints!
When you define a foreign key or primary key in PostgreSQL, it is enforced at the database level, not just in the application

How PostgreSQL Works with FastAPI
You typically use SQLAlchemy (ORM) or Tortoise ORM to connect PostgreSQL with FastAPI.

Let’s walk through it

Define Your Models with Relationships
# models.py

from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship
from database import Base

class Application(Base):
    __tablename__ = "applications"
    id = Column(Integer, primary_key=True, index=True)
    customer_name = Column(String)

class ChatLog(Base):
    __tablename__ = "chat_logs"
    id = Column(Integer, primary_key=True, index=True)
    application_id = Column(Integer, ForeignKey("applications.id"))  # FK enforced!
    message = Column(String)

    application = relationship("Application")


Create the Tables (with Constraints)

alembic upgrade head


@app.post("/chat")
def add_message(msg: ChatMessageSchema, db: Session = Depends(get_db)):
    chat = ChatLog(**msg.dict())
    db.add(chat)
    db.commit()
    return {"status": "message added"}

psycopg2.errors.ForeignKeyViolation: insert or update on table "chat_logs" violates foreign key constraint



Feature	PostgreSQL + FastAPI
Primary key	✅ Auto-enforced via schema
Foreign key	✅ Enforced; DB will reject invalid IDs
Cascading deletes/updates	✅ Supported with ON DELETE CASCADE
Transactions	✅ Built-in with db.commit()
Schema migrations	✅ Use Alembic


Concept	MongoDB	PostgreSQL + FastAPI
Primary Key	Yes (_id)	Yes (id, auto-incremented or UUID)
Foreign Key	❌ Not enforced	✅ Enforced (FK constraints)
Validation	Manual in app	Automatic at DB level
Best ORM	Mongoose	SQLAlchemy or Tortoise ORM


from sqlalchemy import Column, Integer, String, ForeignKey, Index
from database import Base

class ChatLog(Base):
    __tablename__ = 'chat_logs'

    id = Column(Integer, primary_key=True)
    application_id = Column(Integer, ForeignKey("applications.id"))
    message = Column(String)

    __table_args__ = (
        Index("idx_chatlogs_application_id", "application_id"),  # 👈 index defined here
    )



def upgrade():
    op.create_index('idx_chatlogs_application_id', 'chat_logs', ['application_id'])

def downgrade():
    op.drop_index('idx_chatlogs_application_id', table_name='chat_logs')



from sqlalchemy import create_engine

engine = create_engine(DB_URL)
with engine.connect() as conn:
    conn.execute("CREATE INDEX IF NOT EXISTS idx_chatlogs_application_id ON chat_logs(application_id)")



Index Naming Conventions (Best Practice)
Index Name	Target Field(s)
idx_<table>_<column>	Single column index
idx_<table>_<col1>_<col2>	Composite index



Summary: How to Create Index in Backend
Method	How to Do It	When to Use
Raw SQL	CREATE INDEX ...	Quick CLI or manual setup
SQLAlchemy ORM	__table_args__ = (Index(...),)	Auto-index with model
Alembic Migration	op.create_index(...)	Production-safe upgrades
Programmatically in Code	conn.execute("CREATE INDEX ...")	One-time setup via script

State Management for Browser Refresh 
------------------------------------
To persist state across refreshes or browser restarts, you need persistent storage like:

Storage Option	Description	Survives Refresh?
Local Storage	localStorage.setItem()	✅ Yes
Session Storage	sessionStorage.setItem()	✅ Yes (per tab)
Cookies	document.cookie	✅ Yes
IndexedDB	For structured, large data	✅ Yes
Redux Persist	Saves Redux store to persistent storage	✅ Yes

Not Survive 
function Counter() {
  const [count, setCount] = React.useState(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}

Survive
function Counter() {
  const [count, setCount] = React.useState(() => {
    const saved = localStorage.getItem('count');
    return saved ? JSON.parse(saved) : 0;
  });

  React.useEffect(() => {
    localStorage.setItem('count', JSON.stringify(count));
  }, [count]);

  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}



FrontEnd Interview Preparation 
------------------------------
Must-Know Topics:
Scopes (var, let, const)
Closures, hoisting
Promises, async/await, event loop
this keyword, arrow functions
Array methods: map, filter, reduce, find
Object destructuring, spread/rest
ES6+ features (e.g., optional chaining ?., nullish coalescing ??)
Deep vs shallow copy
Type coercion and comparisons
Debounce vs throttle

Must-Know Concepts:
JSX and rendering logic
Functional components
useState, useEffect, useRef, useMemo, useCallback
Props vs state
Lifting state up
React Router (navigation and route params)
Controlled vs uncontrolled components
Form handling
Conditional rendering
Error boundaries (basic)
Keys in lists and their importance
Why does React need keys in a list? What happens if you use index?


TypeScript is expected in most mid-to-senior frontend roles now.

Must-Know Topics:
Type annotations: variables, functions, props
Interfaces vs types
Generics (basic)
Union types, optional types
Enums
Type narrowing, type guards
any, unknown, never, void


Component Design and Architecture
Reusable components (button, modal, form, etc.)
Props drilling vs context
Folder structure
Separation of concerns (e.g., logic vs UI)

State Management
useState, useReducer
Context API (lightweight global state)
Redux / Zustand / Jotai (know at least one if asked)

API Integration
Fetch / Axios
useEffect for calling APIs
Handling loading/error/success states
Optional: React Query or SWR

Basic HTML & CSS Knowledge
Semantic HTML
Flexbox & Grid
Responsiveness (media queries)
CSS-in-JS (e.g., styled-components, Tailwind)
Optional: CSS modules, SASS


Testing (Basic)
Unit tests with Jest
Component testing with React Testing Library
Even if you don’t write full tests, know:
render, fireEvent, getByText, etc.
Why testing is useful in React

Tooling & Environment
Vite / Webpack / Create React App
ESLint, Prettier
npm/yarn, scripts
Git basics


Soft Skills & System Design (Optional but Valuable)
How do you handle component scaling?
How do you organize your React project?
How would you handle a shared state across deeply nested components?
What’s the most challenging bug you’ve solved?


Live Coding Practice
Build a to-do list, form with validation, API data table
Solve a few problems on LeetCode (Easy) or Frontend Mentor
Review common DOM manipulation tasks


Area	Must Know
JavaScript	Closures, async, array methods, scope
React	useState, useEffect, props, routing
TypeScript	Interfaces, types, unions, generics (basic)
APIs	Fetch, async calls, error handling
Styling	Flexbox, responsive, basic CSS
Testing	Jest + RTL (basic usage)
Project Structure	Clean, modular, reusable components


UML 
---
UML stands for Unified Modeling Language.
It’s a visual language used to model, design, and describe software systems.

To visualize system structure and behavior
To document architecture clearly
To communicate design with developers, clients, and stakeholders
To help in planning, analysis, and documentation

1. Structural Diagrams – Show what the system is made of
Diagram Type	Description
Class Diagram	Shows classes, attributes, and relationships
Component Diagram	Shows high-level system components/modules
Object Diagram	Snapshot of objects at runtime
Deployment Diagram	Shows hardware and network setup
Package Diagram	Organizes classes into packages


2. Behavioral Diagrams – Show how the system behaves
Diagram Type	Description
Use Case Diagram	Shows user interactions (user stories)
Sequence Diagram	Shows message flow between components
Activity Diagram	Shows workflow or business logic
State Diagram	Shows states and transitions of a system or object


Example: Class Diagram (Most Common)
Let’s say you’re designing a chat application.

Class Diagram:

+------------------+
|     ChatLog      |
+------------------+
| - id: int        |
| - message: string|
| - timestamp: Date|
| - applicationId: int |
+------------------+

        ▲
        |
        |
+------------------+
|   Application    |
+------------------+
| - id: int        |
| - customerName: string |
+------------------+

This shows:

Two classes (ChatLog, Application)

One-to-many relationship (Application has many ChatLogs)


Tools to Draw UML
Lucidchart
Draw.io
StarUML
PlantUML (code-based UML)
Microsoft Visio

What is UML?	A standard visual language for designing systems
Why use UML?	To visualize, communicate, and document design
Types of UML?	Structural (class, component) + Behavioral (use case, sequence)
Tools to draw?	Lucidchart, Draw.io, PlantUML, etc


Figma
-----
Figma is a browser-based design tool used for UI/UX design, prototyping, and collaborating on frontend interfaces.
Because frontend developers need to convert designs into real code — and Figma is where designers usually create those designs

How Frontend Developers Use Figma
What Designers Do in Figma	What You Do as a Developer
Design UI (buttons, pages, layouts)	Look at the layout and implement it in code (HTML/CSS/React)
Choose fonts, colors, spacing, icons	Copy those styles into CSS
Create interactive prototypes	Understand behavior and flow
Organize components (buttons, forms)	Build reusable components
Share links to the design	Use "Inspect" to get details like font-size, padding, etc.


What You Can Do with a Figma File (As a Dev)
✅ Inspect spacing, padding, and layout
✅ Copy CSS styles directly
✅ Download assets (SVGs, images, icons)
✅ Understand how screens are connected
✅ Get font, color, border-radius, etc.
✅ Check responsive behavior (frame sizes)

Example Workflow
1. Designer gives you a Figma link
They say: "Here’s the UI design for the dashboard page."
2. You open it in browser
No need to install anything — just click the link.
3. You click a button in Figma
You see:
Font: Roboto, 16px
Padding: 12px 24px
Color: #1D4ED8
Border-radius: 6px
4. You build it in code:
<button className="px-6 py-3 text-base bg-blue-600 rounded-md text-white">
  Submit
</button>

Bonus: Figma + Tailwind + React
If your team uses Tailwind CSS, you can often map Figma styles directly to Tailwind classes based on Figma measurements.

And if you're using component libraries (e.g., Material UI, Chakra), you can recreate Figma designs using prebuilt components.


Figma Is Collaborative
Multiple people can view/edit at once (like Google Docs)
Developers + designers can leave comments
Version history is built-in

Question	Answer
What is Figma?	A browser-based UI/UX design and prototyping tool
Who uses it?	Designers, developers, product teams
Do I design in it as a dev?	No — you read, inspect, and extract styles/assets
Why is it important?	It helps you turn designs into accurate frontend code
What can I get from Figma?	Fonts, colors, spacing, icons, layout, and even CSS suggestions

LLM Orchestration
-----------------
Tool/Framework	Role in Orchestration
LangChain	Prompt chaining, agent creation, tool use
LlamaIndex	Indexing and retrieval for RAG
Semantic Kernel	Microsoft’s orchestration for AI workflows
CrewAI / AutoGen	Agent-based orchestration
OpenAI Functions	Let LLMs call tools & APIs

Prompt Management:
Dynamically generating and structuring prompts.
Using prompt templates and chaining them across tasks.

Tool Use / Tool Integration:
Letting the LLM use external tools or APIs (e.g. search engines, calculators, databases).
Frameworks like LangChain, LlamaIndex, and Semantic Kernel handle this.

Memory & Context Management:
Storing and retrieving conversation history, long-term memory, or user data.
Avoiding LLM context window limitations.

Agent Management:
Using LLMs to create autonomous agents that can plan, decide, and act.
Orchestrating how these agents interact with one another or with humans.

Workflow Control / Task Planning:
Structuring tasks into sequences (e.g. first get data → then analyze → then report).
Handling branching logic, retries, or human-in-the-loop steps.

Data Augmented Generation (RAG):
Combining the LLM with real-time or external knowledge sources.
Retrieval-Augmented Generation is a common orchestration technique.


Scalability: Enables building full applications (not just chatbots).
Robustness: Manages edge cases, failures, and retries.
Interactivity: Makes LLMs work with tools, APIs, and users dynamically.
Customization: Allows tailoring responses to business or user-specific needs.


Key Points Have to Address 
1) Intially Worked as the Software Developer 
   Facilitate the Settlement & Payment System 
   Testing - Unit Testing, UAT Testing, 
   Release Mangement 
   Production Support Root Cause Analysis 
   Interacting with Client 
So I'm Proficient with Complete Software Development Lifecycle SDLC and BFSI Domain Knowledge 

2) I have Crossed Skilled from scracth in AI/ML Technologies and then got opportunities to Work as a AI Engineer 
  So I'm currently working in Developing the Agentic RAG System, The Usecase is to do the end-end to analysis & assessment for Loan Approval Process for institutional borrowers
so here my contribution is 
    in Data Engineering
       LLM Orchestration 
       LLM Application Testing 

3) These are my skillsets I have in GenAI tech 

i would like to do Research Every day to get up to date with AI Technologies 
4) and my strength is I'm good at Mathematically understanding the Artifical Intellgience, So Could able to contribute more and optimize and provide the Good Strategies in use of AI Technologies 

LLM Evaluation and Evaluation Metrics 
Azure AI Foundry 
Azure Function 
Agentic Course Recap 
GenAI Stack 
Programming Questions 


Coding Question
---------------
1.sorted(x,key=) -> Done
2. from collections import OrderedDict     -> Done
dicts = OrderedDict({"siva":"ra","Siva":"daj"})
dicts = OrderedDict([("siva","raj"),("dha","Siv"),("si","ra")])
dicts.move_to_end("siva")
print(dicts)
3. zip   --> Done
4. enumerate --> Done
5. [expression for item in iterable if condition]  --> Done 
6. Filter = list(filter(lambda,list)) - filter(None,list) -> Done
7. Map = list(map(lambda,list) 
8. Reduce = reduce(lambda x, y: x + y, numbers) 
            reduce(lambda x, y: x if x > y else y, numbers)
            reduce(lambda x, y: x + y, numbers, 10)
9. a = defaultdict(int)
       defaultdict(list) 
       defaultdict(lambda: "Not Found")
10. __slot__ -> avoid memory usage and speed up the attribute access, we can't add the attribut outside the class 
11. class Person:
    __slots__ = ['name', 'age']  # only these attributes are allowed

    def __init__(self, name, age):
        self.name = name
        self.age = age

p = Person("Alice", 30)
print(p.name)  # Alice
print(p.__slots__)  # ['name', 'age']
12.enum 
from enum import Enum

class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3
13.# Access members
print(Color.RED)          # Color.RED
print(Color.RED.name)     # 'RED'
print(Color.RED.value)    # 1

# Comparison
print(Color.RED == Color.RED)   # True
print(Color.RED == Color.GREEN) # False

# Iterating through members
for color in Color:
    print(color.name, color.value)
14.nums = list(map(int, input("Enter numbers: ").strip().split()))
15.class MyClass:
    class_var = 0

    def __init__(self):
        MyClass.class_var += 1

    @classmethod
    def get_instance_count(cls):
        return cls.class_var

class Person:
    def __init__(self, name):
        self.name = name

    @classmethod
    def from_string(cls, data):
        name = data.strip()
        return cls(name)

p = Person.from_string(" Alice ")
print(p.name)  # Alice

16. from functools import lru_cache

@lru_cache(maxsize=3)
def fetch_data(x):
    print(f"Fetching {x}...")
    return x * x

fetch_data(2)
fetch_data(3)
fetch_data(4)
fetch_data(2)  # This won't trigger the print because 2 is cached
fetch_data(5)  # Evicts 3 (Least Recently Used if maxsize=3)



from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.cache = OrderedDict()
        self.capacity = capacity

    def get(self, key):
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)  # mark as recently used
        return self.cache[key]

    def put(self, key, value):
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)  # remove least recently used



1. LeetCode - Two Sum  - 1
     num_map = {}
     for i, num in enumerate(nums):
           complement = target - num 
           if complement in num_map:
              return [num_map[complement],i]  
           num_map[num] = i 

2. LeetCode - Contains Duplicate - 217
a = [1, 2, 3]
if len(a) == len(set(a)):
    print("False")
else:
    print("True")

3. LeetCode ---> Intersection of Two Arrays   --> 350  
from collections import Counter

def intersect(nums1, nums2):
    counts = Counter(nums1)  # Step 1
    result = []

    for num in nums2:  # Step 2
        if counts[num] > 0:  # Step 3
            result.append(num)
            counts[num] -= 1  # Step 4

    return result

4. LeetCode - Valid Anagram - 242 

5. LeetCode - Group Anagram - 49 
Hash_map and sorted - defaultdict
defaultdict(int,str,set,dict) 


6. Leetcode - Subset - distinct integer - powerset - 78
   Backtracking / DFS
   Use recursion to include or exclude each element.
a = [1,2,3]

results = [[]]
for i in a:
    print(results)
    results = results + [curr + [i] for curr in results]
    print(results)
print(results)






1. Storing , and after that checking that if present or not
2. Removal of list in if condition, not in the for loop 
3. Two Pointer Concept i and j alone 
4. from collections import Counter 
5. from collections import OrderedDict 
6. from collections import defaultdict 
7. sorted(,key=) will not work for list 






set --> add()









 










































