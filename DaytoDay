July 2025

Index
Top Reasearcher 
Evals and Benchmarks - LLM
RAG Evaluation 
Evaluating LLM-Based Agents
State Management in Backend
Authentication Methods
Session-Based Authentication 
Query Param 
MongoDB - Key  




Top Reasearcher 
---------------
Trapit Bansal - RL CoT - o-series model at openAI
Shuchao Bi - co-creater of GPT-4o voice mode and o4-mini 
             Multi-modal Post-Training at OpenAI 
Huiwen Chang - co-creator of GPT-4o's image generation, 
             - MaskGIT and Muse text-to-image architectures at Google Research 
Ji Lin - o3/o4-mini, GPT-4o, GPT-4.1, GPT-4.5, 4o-imagegen and Operator Reasoning stack 
Joel Pobar - Inference at Anthropic. 
Jack Rae - pre-training tech lead for Gemini and reasoning for Gemini 2.5. Led Gopher and chinchilla early 
           LLM efforts at Deepmind
Hongyu Ren - Co-Creator of GPT-4o, 4o-mini, o1-mini o3-mini, o3 and o4-mini. Previously leading a group for post-training of OpenAI 
Johan Schalkwyk - former Google Fellow, 
Pei Sun - post-Training, coding, and reasoning of Gemini at Google Deepmind
          Waymo's Perception models 
Jiahui Yu - co-creator of o3, o4-mini, GPT-4.1 and GPT-4o. Previously led the perception team at OpenAI, and co-led multimodal at Gemini
Shengjia Zhao - ChatGPT, GPT-4, all mini models, 4.1 and o3. Previously synthetic data at openAI
Alexandr Wang: Chief AI Officer Meta - Scale AI Company

Evals and Benchmarks - LLM
--------------------
Benchmarks - Standardized tests / Evaluation suites used to measure and compare the performance of different models
             across a variety of tasks.
 - These Benchmarks help researchers, developers, and users understand how well an LLM performs in specific areas 
 - Reasoning - Comprehension - Coding - Translation - Safety 

Common Benchmarks
MMLU
HELLASWAG
ARC
GSM8K 
BIG-Bench (BBH) 


Evaluation Metrics - NLP Evaluation
-----------------------------------
The model's prediction is compared to the labeled ground truth 
Metrics like Accuracy, BLEU, F1, pass@k, ROUGE etc are used depending on the task 

Classification        - Accuracy, F1      
QA (Short answer)     - Exact Match (EM), F1
Translation           - BLEU, METEOR 
Code Generation       - pass@k, correctness 
Summarization         - ROUGE, BLEU 
Math (GSM8K)          - Exact answer matching 

RAG Evaluation 
--------------
Evaluate Retrieval Quality - Are you retrieving the right context documents
Recall@k    - % of times the correct doc is in top-k 
Precision@k - % of top-k docs that are relevant 
MMR - Mean Reciprocal Rank 
nDCG - Ranking Quality of relevant documents

def recall_at_k(retrieved_docs,relevant_docs,k=5):
  hits = sum([1 for doc in retrieved_docs[:k] if doc in relevant_docs])
  return hits / min(k,len(relevant_docs))

Evaluate Generation Quality - Is the final answer accurate, complete or grounded 
Exact Match - Text match with groun-truth answer 
ROUGE/BLEU  - Token overlap (for summaries/QA) 
Faithfulness/Groundedness - Is the answer supported by retrieved docs
F1 Score - Partial Match (word overlap, e.g. for QA) 
Human Eval - Best for complex answers (correct, useful) 

def exact_match(pred, label):
  return pred.strip().lower() == label.strip().lower()

Evaluate Faithfulness / Hallunciation - Specific to RAG
Is the Answer based only on retrieved documents, or is it hallucinating 
Attribution/Grounding Tests : Does Every fact appear in the source 
RAGAS (Hugging Face): End-to-End RAG Evaluation Tool 

from ragas.evaluation import evaluate 
from ragas.metrics import faithfulness, answer_relevancy
results = evaluate(questions=questions,contexts=contexts,answers=answers,metrics=[faithfulness,answer_relevancy],)
print(results)

Pipeline for RAG - Evaluation 
  {"query":
  "retrieved_docs":
  "generated_answer":
  gold_answer":
}
you can evaluate 
Retrieval: Does Retrieved_docs include the sentence about Paris ?
Generation: Does generated_answer match gold_answer
Grounding: Is "Paris" found in retrieved_docs ?


Retrieval - FAISS BM25 ColBERT
Generation -  GPT, T5, LLaMA, etc 
Evaluation - RAGS, Llamaindex Evals, Trulens, Langchain evals 

Building a Test set for RAG evaluation 
Implementing custom metrics 
Comparing two RAG versions (e.g. BM25 vs embedding retriever) 

Evaluating LLM-Based Agents 
---------------------------

Evaluating AI Agents 
Agent Capabilities Evaluation - Planing and Multi-Step Reasoning  - AQUA-RAT
                                Function Calling - Tool Use 
                                Self-Reflection 
                                Memory 
                          
Application-Specific Agent Evaluation - 
Generalist Agents Evaluation 
Frameworks for Agent Evaluation 


Agentic AI's Web Search and Reasoning capabilities involves a multi-dimensional approach. 
- Compile a dataset of queries that cover
  Typical Searches 
  Edge Cases - vague, ambiguous or trick questions
  Multi-Step Tasks - requiring search + synthesis 

Quantitative Metrics 
Apply both Information Retrieval (IR) and agenti-specific metrics
IR Metrics 
* Precision@k, Recall, nDCG - measure relevance and ranking quality 
* Session success rate/ CTR - track how often user clicks or engages meaninfully 

Agentic AI Metrics (from Galileo's taxonomy) 
System Metrics: Latency, token usage, cost per task 
Task Success: Percentage of tasks completed correctly
Quality - instruction adherence, output format, factual accuracy
Tool Interaction - correct tool selection and parameter usage 

Tool-call accuracy - Did it choose and use the search tool appropriately 
Plan-Exectuion - Where intermediate steps logical and necessary ? Logging Traces/ 

Benchmark with known Evaluations
Designed for web-browsing agents
WebGames, BEARCUBS - simulate realistic browsing and retrieval scenarios 
InfoDeepSeek - evaluates retrieval + generation quality 


Drift in Tool Usage 
Retrieval quality 

Compare different versions v1 and v2 using statistical significance tests to validate improvements

State Management in Backend  - Like Flask & Django & FastAPI
---------------------------
State Management in the backend refers to how a web application tracks and manages data across different user interactions, sessions, or requests. 
Since HTTP is stateless by default (each request is independent and doesn't retain memory of previous interactions), backend frameworks like FastAPI, Flask, and Django need to explicitly implement ways to maintain state across requests

State Type	Description
Session State	Keeps user-specific data (e.g. login info) across requests.
Application State	Data shared across all users during the lifetime of the app (e.g. cache).
Request State	Temporary data for a single HTTP request.
Database State	Persistent data stored in a DB and retrieved as needed.

State Management in FastAPI, Flask, Django
1. Request State
Handled automatically. Each request has its own context.
Flask: via request object from flask package
FastAPI: via dependency injection (request passed into endpoint)
Django: via request object in view functions

from fastapi import Request

@app.get("/")
def read_root(request: Request):
    client_host = request.client.host
    return {"client": client_host}


2. Session State (User-specific data)
Flask: Has a built-in session object backed by cookies (signed with secret key).
FastAPI: No built-in session support, but can be added using middleware or third-party packages like starlette.middleware.sessions.
Django: Built-in session middleware with support for DB, cache, or file-based sessions.


from flask import session

@app.route('/login')
def login():
    session['user'] = 'sivaraj'
    return 'Logged in'

from starlette.middleware.sessions import SessionMiddleware

app.add_middleware(SessionMiddleware, secret_key='your-secret')

@app.get("/set-session")
def set_session(request: Request):
    request.session["user"] = "sivaraj"
    return {"message": "session set"}


3. Application State
Shared across all requests and users.
Flask: Use app.config or global variables (not recommended for complex apps).
FastAPI: Use app.state for app-level storage.
Django: Usually uses caching or settings module for shared state.


@app.on_event("startup")
def startup_event():
    app.state.model = load_your_model()

@app.get("/predict")
def predict():
    model = app.state.model
    return model.predict(...)

4. Persistent State (Database)
State stored in a database is the most reliable way to manage long-term state across users and sessions.
Django uses ORM (models.py) and handles state via database.
Flask and FastAPI typically use SQLAlchemy, Tortoise ORM, Beanie (MongoDB), etc

Additional Considerations
Authentication/Authorization: Uses session, JWT, or OAuth to manage state.
Caching: Redis or Memcached can store temporary shared or user-specific state.
WebSocket State: Use connection state in memory or Redis for real-time apps.

Framework	Session Support	Application State	ORM/DB Integration
Flask	Built-in (session)	g, app.config	SQLAlchemy, etc.
FastAPI	Via Middleware	app.state	SQLAlchemy, Tortoise, Beanie
Django	Built-in Middleware	Django settings/cache	Django ORM


Authentication/Authorization in Backend (State Management Perspective) 
Since HTTP is stateless, we need to use mechanisms like sessions, JWT, or OAuth tokens to maintain user-specific data (i.e., state) across multiple requests after the user logs in

Authentication	Verifying who the user is (e.g., username/password).
Authorization	Verifying what the user is allowed to do (e.g., access certain APIs).

Once a user logs in (authenticates), we need a way to remember who they are on every subsequent request.
That‚Äôs where state comes in ‚Äî by using Session, JWT, or OAuth mechanisms

1. Session-based Authentication (Server-Side State)
Stores user login info in memory or database on the server.
Sends a session ID to the client as a cookie.
On each request, the client sends the session ID; the server looks up the user.

Django Example 
# Login view in Django
def login_view(request):
    if request.method == "POST":
        user = authenticate(username="sivaraj", password="pass")
        if user:
            login(request, user)  # Django stores session

Server-side state:
Stored in DB or cache (Redis).
Requires server memory or infrastructure to maintain sessions.
More secure but harder to scale horizontally.

2. JWT (JSON Web Token) - (Stateless Authentication)
Once user logs in, the server issues a signed token.
This token contains user info, expiry, and is self-contained.
On every request, the client sends the token (usually in the Authorization header).

from fastapi import Depends, HTTPException
from fastapi.security import OAuth2PasswordBearer
import jwt

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        user = payload.get("sub")  # user identifier
        return user
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")

Client-side state:
Stored in the browser or app (e.g., localStorage or memory).
Scales easily (stateless).
Needs good security practice (e.g., token rotation, short expiry).

Client-side state:
Stored in the browser or app (e.g., localStorage or memory).
Scales easily (stateless).
Needs good security practice (e.g., token rotation, short expiry).

3. OAuth2 / OpenID Connect (Third-party Authentication)
Used to delegate authentication to another provider like Google, GitHub, Facebook.
Users login via a third-party.
You get a token (like JWT or an access token).
You use that token to access APIs.

Used in: Social login, enterprise apps, microservices
Example flow:
User clicks "Login with Google"
Redirected to Google, they log in
Redirected back to your app with authorization code
Your app exchanges code for access token
You can now access user data or validate session

Method	Where is State Stored?	Stateless?	Notes
Session	On the server (DB, memory, Redis)	‚ùå No	Easy to manage but hard to scale horizontally
JWT	In the token (client-side)	‚úÖ Yes	Fast and scalable; no need to store anything on server
OAuth2	On client + third-party auth server	‚úÖ Mostly	You trust another system to manage auth and token


I can provide:

Session-based login for Django/Flask
JWT login with FastAPI
OAuth login using Google
Let me know your use case (e.g., REST API with JWT for React frontend), and I‚Äôll give you full code for that.


Login Method
-------------
POST /login
Content-Type: application/json

{
  "username": "sivaraj",
  "password": "your_password"
}


200 OK
Content-Type: application/json

{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJzaXZhcmFqIiwibmJmIjoxNzI5MDY5NDIwLCJleHAiOjE3MjkwNzMwMjB9.uCdpDShc4PQfGm5GL7FYuPC7KnFgPMql0yz1LBKTt20",
  "token_type": "bearer"
}

The token is signed with a secret key and may include:
sub: subject (user ID or username)
exp: expiration time
nbf: not before time
any custom claims (roles, scopes, etc.)


3. Client Stores the JWT
Client stores the token in memory or browser storage:
Browser: localStorage, sessionStorage
React/Frontend App: Redux store or local variable


GET /user/profile
Authorization: Bearer <JWT_TOKEN_HERE>

Decodes the token using the secret key.
Verifies exp, nbf, and sub.
If valid, returns data; else returns 401 Unauthorized


200 OK
Content-Type: application/json

{
  "username": "sivaraj",
  "email": "sivaraj@example.com",
  "role": "admin"
}



Authentication Methods 
----------------------
Auth Method	Where State is Stored	Stateless?	Suitable For	Pros	Cons
Session-Based	Server (DB, Redis, memory)	‚ùå No	Traditional web apps (Django, Flask), server-rendered UIs	Easy to implement, built-in CSRF protection	Not scalable across multiple servers without shared session
JWT (Token)	Client (token in header)	‚úÖ Yes	SPAs (React/Vue), mobile apps, APIs, microservices	Scales easily, no server-side state	No built-in logout, token revocation is hard
OAuth2 / OIDC	Client + 3rd-party provider	‚úÖ Mostly	Login via Google, GitHub, Facebook, enterprise SSO	Delegated auth, secure, standard for large systems	Complex to implement, requires trust in provider
API Key	Client (key in header)	‚úÖ Yes	Internal services, server-to-server communication	Simple, fast	No user context, poor granularity, hard to rotate securely
Basic Auth	Client (username:password)	‚úÖ Yes	Quick prototyping, scripts	Extremely simple	Insecure (no hashing), credentials sent on every request


Basic Authentication
How it works: Username and password encoded in Base64 and sent in each request.
Use when:
Quick development or testing scripts.
Internal systems without sensitive data.
Not recommended for production without HTTPS.

 API Key Authentication
How it works: A unique key is provided per client; key is passed in the header of every API call.
Use when:
It's a backend-to-backend system.
You don't need user-specific data, just service-level access.
Example: A backend service pulling weather data using an API key.


3. OAuth2 / OpenID Connect
How it works: Uses authorization servers (like Google) to authenticate and provide access tokens.
Use when:
You want SSO (Single Sign-On).
You want to allow users to log in using existing identities (Google, Microsoft).
You‚Äôre building enterprise or third-party integration apps.
Example: "Login with Google" on a SaaS product.

 JWT (JSON Web Token)
How it works: Server returns signed token (JWT) on login; client stores it and sends in Authorization header.
Use when:
You're building SPAs with React, Angular, or Vue.
You need stateless and scalable APIs.
You have mobile apps or microservices architecture.
Example: React + FastAPI frontend/backend combo with mobile clients.


Session-Based Authentication
How it works: Server stores session ID after login; client stores session ID in a cookie.
Use when:
You use server-rendered pages (like in Django or Flask templates).
You don‚Äôt need to scale horizontally without session stores.
Example: Classic web dashboard for internal admin system.


Session-Based Authentication
Session-Based Authentication Requires Server-Side State

In session-based authentication, the user session is stored on the server, often in:
Memory (RAM)
A local file
A database
A shared session store like Redis

So, when a user logs in:
Server generates a session ID
Server stores the session data (e.g., user info) on the server
Server sends back a cookie with session ID to the client
Client sends that cookie in each request
Server looks up the session using the session ID

Horizontal Scaling = Multiple Servers
Horizontal scaling means adding more servers or instances (e.g., in a load-balanced setup) to handle more traffic.
                 +-------------+
User ‚Üí Internet ‚Üí| LoadBalancer|‚Üí Server 1
                 +-------------+‚Üí Server 2
                                 Server 3

A user logs in, and Server 1 stores their session in its memory.
Next request goes to Server 2 (due to load balancing).
Server 2 doesn't have that session info, so the user appears logged out or gets an error.


If sessions are stored only in each server‚Äôs local memory, then:
"You can't scale horizontally"
...unless you use a shared session store (like Redis) accessible by all servers.

Solution: Session Store (Shared State)
All servers connect to Redis or Database to fetch session info.

No matter which server handles the request, it can find the session.

plaintext
Copy
Edit
Client ‚Üí Load Balancer ‚Üí Server 1 or Server 2
                       ‚Üò Redis (shared session store)



JWT Doesn‚Äôt Have This Problem
JWT is stateless
No session is stored on the server
The token carries all necessary user info
Any server can validate it using a shared secret key
So JWT is better suited for horizontal scaling, especially in cloud-native or microservice-based apps.


Concept	Session-Based	JWT-Based
Needs shared session store?	‚úÖ Yes	‚ùå No
Scales easily across servers?	‚ùå Only with shared store	‚úÖ Yes
Stores state on server?	‚úÖ Yes (session data)	‚ùå No (client stores JWT)


Param in API 
------------
Value	How You Get It	Where It Comes From
rm_id	From JWT token	After login (attached to auth header)
application_id	From route or page context	URL param or selected application
message	From form input	RM types in message box


GET Chat History (with Path and Query Params)
GET /api/applications/abc123/chat?limit=50&sort=desc


Use Case	Parameter Type to Use	Why
Identify a specific resource	Path Param	Cleaner, more RESTful: /applications/123
Filter/sort/paginate a list	Query Param	Optional and flexible: ?sort=desc
Send structured data	Body Param (POST/PUT)	Useful for complex inputs like forms or messages
Auth, content negotiation	Header Param	Metadata like tokens or content type


Query Param 
-----------
Query parameters are part of the URL, used to send optional data like filters, pagination, search terms, etc.
They appear after the ? in the URL.
Multiple query params are joined with &

Let‚Äôs say you want to fetch chat history for an application:
// JavaScript/React/Frontend
const applicationId = 'abc123';
const limit = 20;
const sort = 'desc';

fetch(`/api/applications/${applicationId}/chat?limit=${limit}&sort=${sort}`, {
  method: 'GET',
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
});


GET /api/applications/abc123/chat?limit=20&sort=desc

app.get('/api/applications/:applicationId/chat', (req, res) => {
  const applicationId = req.params.applicationId; // from path
  const limit = req.query.limit; // from query string
  const sort = req.query.sort;

  console.log(applicationId); // "abc123"
  console.log(limit);         // "20"
  console.log(sort);          // "desc"

  // Use these values to fetch data from DB
});



def chat_view(request, application_id):
    limit = request.GET.get('limit')  # "20"
    sort = request.GET.get('sort')    # "desc"
    # application_id is from the path

    # You can use these to query the database


from fastapi import FastAPI, Query

@app.get("/api/applications/{application_id}/chat")
def get_chat(application_id: str, limit: int = Query(20), sort: str = Query("desc")):
    return {
        "application_id": application_id,
        "limit": limit,
        "sort": sort
    }


Param	Example	Used For
limit	?limit=50	Pagination
offset	?offset=10	Skip records (pagination)
sort	?sort=asc	Sort order
filter	?status=InProgress	Filter by status or keyword
search	?q=John	Search text


Always validate query params on the backend.
Provide default values in case params are missing.
Be strict with types (especially int, bool, etc.).


Frontend builds URL with ?key=value format.
Backend reads them via req.query (Express), request.GET (Django), or as function args (FastAPI).
Ideal for optional parameters like filters, sorts, and pagination.


MongoDB - Key  
------------
Note: MongoDB won‚Äôt validate that application_id: "app123" actually exists in applications. You have to enforce this in your application logic

Option	Description
Manual Checks	Validate references in code before inserting/updating
Data Embedding	Embed related data if it's read together and not huge
Two-Phase Commits	Use transactions (MongoDB 4.0+) for atomicity across collections
Mongoose (ODM)	Provides schema models and can define references


const ChatLogSchema = new mongoose.Schema({
  application_id: { type: mongoose.Schema.Types.ObjectId, ref: 'Application' },
  message: String
});


Excellent question ‚Äî let's look at how PostgreSQL works with FastAPI, especially regarding primary keys, foreign keys, and validation. This is one of the biggest differences between a relational (SQL) database like PostgreSQL and a NoSQL DB like MongoDB

Yes ‚Äî PostgreSQL enforces key constraints!
When you define a foreign key or primary key in PostgreSQL, it is enforced at the database level, not just in the application

How PostgreSQL Works with FastAPI
You typically use SQLAlchemy (ORM) or Tortoise ORM to connect PostgreSQL with FastAPI.

Let‚Äôs walk through it

Define Your Models with Relationships
# models.py

from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship
from database import Base

class Application(Base):
    __tablename__ = "applications"
    id = Column(Integer, primary_key=True, index=True)
    customer_name = Column(String)

class ChatLog(Base):
    __tablename__ = "chat_logs"
    id = Column(Integer, primary_key=True, index=True)
    application_id = Column(Integer, ForeignKey("applications.id"))  # FK enforced!
    message = Column(String)

    application = relationship("Application")


Create the Tables (with Constraints)

alembic upgrade head


@app.post("/chat")
def add_message(msg: ChatMessageSchema, db: Session = Depends(get_db)):
    chat = ChatLog(**msg.dict())
    db.add(chat)
    db.commit()
    return {"status": "message added"}

psycopg2.errors.ForeignKeyViolation: insert or update on table "chat_logs" violates foreign key constraint



Feature	PostgreSQL + FastAPI
Primary key	‚úÖ Auto-enforced via schema
Foreign key	‚úÖ Enforced; DB will reject invalid IDs
Cascading deletes/updates	‚úÖ Supported with ON DELETE CASCADE
Transactions	‚úÖ Built-in with db.commit()
Schema migrations	‚úÖ Use Alembic


Concept	MongoDB	PostgreSQL + FastAPI
Primary Key	Yes (_id)	Yes (id, auto-incremented or UUID)
Foreign Key	‚ùå Not enforced	‚úÖ Enforced (FK constraints)
Validation	Manual in app	Automatic at DB level
Best ORM	Mongoose	SQLAlchemy or Tortoise ORM


from sqlalchemy import Column, Integer, String, ForeignKey, Index
from database import Base

class ChatLog(Base):
    __tablename__ = 'chat_logs'

    id = Column(Integer, primary_key=True)
    application_id = Column(Integer, ForeignKey("applications.id"))
    message = Column(String)

    __table_args__ = (
        Index("idx_chatlogs_application_id", "application_id"),  # üëà index defined here
    )



def upgrade():
    op.create_index('idx_chatlogs_application_id', 'chat_logs', ['application_id'])

def downgrade():
    op.drop_index('idx_chatlogs_application_id', table_name='chat_logs')



from sqlalchemy import create_engine

engine = create_engine(DB_URL)
with engine.connect() as conn:
    conn.execute("CREATE INDEX IF NOT EXISTS idx_chatlogs_application_id ON chat_logs(application_id)")



Index Naming Conventions (Best Practice)
Index Name	Target Field(s)
idx_<table>_<column>	Single column index
idx_<table>_<col1>_<col2>	Composite index



Summary: How to Create Index in Backend
Method	How to Do It	When to Use
Raw SQL	CREATE INDEX ...	Quick CLI or manual setup
SQLAlchemy ORM	__table_args__ = (Index(...),)	Auto-index with model
Alembic Migration	op.create_index(...)	Production-safe upgrades
Programmatically in Code	conn.execute("CREATE INDEX ...")	One-time setup via script








































